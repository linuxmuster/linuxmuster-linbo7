#!/bin/sh
# linbo_cmd - Backend worker script for LINBO
# (C) Klaus Knopper 2007-2010
#
# ssd/4k/8k support - jonny@bzt.de 30.09.2012 alpha!
# ssd/4k/8k support - jonny@bzt.de 06.11.2012 anpassung fuer 2.0.12
#
# thomas@linuxmuster.net
# 20221212
# GPL v3
#

RSYNC_PERMISSIONS="--chmod=ug=rw,o=r"
RSYNC_SKIP_COMPRESS="/7z/arc/arj/bz2/cab/cloop/deb/gz/gpg/iso/jar/jp2/jpg/jpeg/lz/lz4/lzma/lzo/png/qcow2/qdiff/qt/rar/rzip/s7z/sfx/svgz/tbz/tgz/tlz/txz/xz/z/zip/zst"
UDEVADM="$(which udevadm)"

trap bailout 1 2 3 10 12 13 15

umask 002

PID="$$"

TMP="/tmp/linbo_cmd.$$.tmp"
rm -f "$TMP"

# Nur zum Debuggen
# echo "»linbo_cmd«" "»$@«"
ps w | grep linbo_cmd | grep -v grep >"$TMP"
if [ $(cat "$TMP" | wc -l) -gt 1 ]; then
  # echo "Possible Bug detected: linbo_cmd already running." >&2
  echo "Moeglicher Fehler erkannt: linbo_cmd laeuft bereits." >> /tmp/linbo.log
  #cat "$TMP" >&2
  cat "$TMP" >> /tmp/linbo.log
fi
rm -f "$TMP"
# EOF Debugging

# set terminal & PATH
export TERM=xterm
export PATH=/bin:/sbin:/usr/bin:/usr/sbin

printargs(){
  local arg
  local count=1
  for arg in "$@"; do
    echo -n "$((count++)): »$arg« "
  done
  echo ""
}

# test if variable is an integer
isinteger() {
  [ $# -eq 1 ] || return 1
  case $1 in
  *[!0-9]*|"") return 1;;
           *) return 0;;
  esac
}

# Is /cache writable?
# Displayed mount permissions may not be correct, do a write-test.
cache_writable(){
  local testfile="/cache/.write_test"
  [ -f "$testfile" ] && rm -f "$testfile" 2>/dev/null
  echo > "$testfile" 2>/dev/null
  local RC="$?"
  [ -f "$testfile" ] && rm -f "$testfile" 2>/dev/null
  return "$RC"
}

# check for forcegrub option
forcegrub(){
  case "$(cat /proc/cmdline)" in *\ forcegrub*) return 0;; esac
  return 1
}

# Check for "nonetwork" boot option or availability of linbo server
localmode(){
  case "$(cat /proc/cmdline)" in *\ nonetwork*|*\ localmode*) return 0;; esac
  [ -e /tmp/network.ok ] && return 1
  return 0
}

# upload logfile to linbo server or store it local in cache
# usage example (logfile parameter is optional): sendlog <name_of_logfile_in_tmp>
sendlog(){
  local RC="1"
  local logfiles="$1"
  [ -z "$logfiles" ] && logfiles="patch.log linbo.log image.log"
  local i
  for i in $logfiles; do
    # add log extension
    logfile="/tmp/$i"
    if [ -s "$logfile" ]; then
      if localmode; then
        if cache_writable; then
          echo "Speichere Logdatei $i im Cache."
          cp "$logfile" /cache
        fi
      else
        [ -e /tmp/linbo-network.done ] || return 0
        echo "Veranlasse Upload von $i."
        logfile="/tmp/$(hostname)_$i"
        rsync --skip-compress="$RSYNC_SKIP_COMPRESS" $(serverip)::linbo"$logfile" "/tmp/$i" 2>"$TMP" || true
      fi
    fi
  done
}

bailout(){
  echo "DEBUG: bailout() invoked, linbo_cmd=$PID, my_pid=$$" >&2
  echo ""
  # Kill all processes that have our PID as PPID.
  local processes=""
  local names=""
  local pid=""
  local cmd=""
  local stat=""
  local relax=""
  local statfile=""
  for statfile in /proc/[1-9]*/stat; do
    while read pid cmd stat ppid relax; do
      if [ "$ppid" = "$PID" ]; then
        processes="$processes $pid"
        names="$names $cmd"
      fi
    done <"$statfile"
  done
  if [ -n "$processes" ]; then
    echo "Killing processes: $processes $names" >&2
    kill $processes
    sleep 1
    echo ""
  fi
  cd /
  sync; sync; sleep 1
  umount /mnt >/dev/null 2>&1 || umount -l /mnt >/dev/null 2>&1
  sendlog
  umount /cache >/dev/null 2>&1 || umount -l /cache >/dev/null 2>&1
  umount /image >/dev/null 2>&1 || umount -l /image >/dev/null 2>&1
  rm -f "$TMP"
  echo "Aborted." >&2
  echo "" >&2
  exit $?
}

interruptible(){
  local RC=0
  # "$@" >"$TMP" 2>&1 &
  "$@" &
  local newpid="$!"
  wait "$newpid"
  RC="$?"
  case "$RC" in
  0) true ;;
  2) kill "$newpid"; cd /; bailout 0 ;;
  #  *) [ -s "$TMP" ] && cat "$TMP" >&2 ;;
  esac
  return "$RC"
}

help(){
  echo "
  Ungueltiger LINBO-Befehl: »$@«

  Syntax: linbo_cmd command option1 option2 ...

  Beispiele:
  start bootdev rootdev kernel initrd append
               - Fahre Betriebssystem hoch
  syncr server  cachedev baseimage image bootdev rootdev kernel initrd
               - Synchronisiere Cache vom Server, dann Partitionen vom Cache
  syncl cachedev baseimage image bootdev rootdev kernel initrd
               - Synchronisiere Partitionen vom Cache

  image variants:
  .qcow2 - compressed partition image in qemu's qcow2 format.
  .cloop - Image vom kompletten Blockgeraet (block device, z.B. Partition), CLOOP-komprimiert
  .rsync - Differentielles RSYNC-Abbild, CLOOP-komprimiert
  " 1>&2
}

cmd="$1"
[ -n "$cmd" ] && shift # Command args are now $@


# fstype partition
# print filesystem type of a partition
fstype(){
  [ -b "$1" ] || return 1
  blkid -o export "$1" | grep ^TYPE | awk -F\= '{print $2}'
}

# tschmitt
# get DownloadType from start.conf
downloadtype(){
  local RET=""
  if [ -s /start.conf ]; then
    RET="$(grep -i ^downloadtype /start.conf | tail -1 | awk -F= '{ print $2 }' | awk '{ print $1 }' | tr A-Z a-z)"
    # get old option for compatibility issue
    if [ -z "$RET" ]; then
      RET="$(grep -i ^usemulticast /start.conf | tail -1 | awk -F= '{ print $2 }' | awk '{ print $1 }' | tr A-Z a-z)"
      [ "$RET" = "yes" ] && RET="multicast"
    fi
  fi
  echo "$RET"
}

# tschmitt
# fetch hostgroup from start.conf
hostgroup(){
  local hostgroup=""
  [ -s /start.conf ] || return 1
  hostgroup=`grep -i ^group /start.conf | tail -1 | awk -F= '{ print $2 }' | awk '{ print $1 }'`
  echo "$hostgroup"
}

# cachedev: prints cache device from start.conf
cachedev(){
  [ -s /start.conf ] || return 1
  grep -iw ^cache /start.conf | awk -F\# '{ print $1 }' | awk -F\= '{ print $2 }' | awk '{ print $1 }' | tail -1
}

# serverip: prints server ip from start.conf
serverip(){
  [ -s /start.conf ] || return 1
  grep -iw ^server /start.conf | awk -F\# '{ print $1 }' | awk -F\= '{ print $2 }' | awk '{ print $1 }' | tail -1
}

# tschmitt
# fetch osname from start.conf
# args: rootpartition
osname(){
  [ ! -b "$1" -o ! -s /start.conf ] && return 1
  local partition="$1"
  local osname
  local rootpart
  local value
  local line
  grep -iw ^[rn][oa][om][te] /start.conf | awk -F\# '{ print $1 }' | while read line; do
    value="$(echo "$line" | awk -F\= '{ print $2 }' | sed -e 's|^ *||')"
    case "$line" in
      [Nn][Aa][Mm][Ee]*) osname="$value" ;;
      [Rr][Oo][Oo][Tt]*) rootpart="$value" ;;
    esac
    if [ -n "$osname" -a -n "$rootpart" ]; then
      if [ "$rootpart" = "$partition" ]; then
        echo "$osname"
        return 0
      fi
      osname=""
      rootpart=""
    fi
  done
  return 1
}

# print kernel options from start.conf
kerneloptions(){
  [ -s /start.conf ] || return 1
  grep -i ^kerneloptions /start.conf | tail -1 | sed -e 's/#.*$//' -e 's/kerneloptions//I' | awk -F\= '{ print substr($0, index($0,$2)) }' | sed -e 's/ =//' -e 's/^ *//g' -e 's/ *$//g'
}

# fschuett
# fetch SystemType from start.conf
systemtype(){
  local systemtype="bios"
  [ -s /start.conf ] || return 1
  systemtype=`grep -iw ^SystemType /start.conf | tail -1 | awk -F= '{ print $2 }' | awk '{ print $1 }'`
  echo "$systemtype"
}

get_64(){
  local is_64=""
  uname -a | grep -q x86_64 && is_64="64"
  echo "$is_64"
}


# fschuett
# extract block device name for sd?,/dev/sd?,*blk?p?,/dev/*blk?p?
# get_disk_from_partition partition
get_disk_from_partition(){
  local p="$1"
  local disk
  expr "$p" : ".*p[[:digit:]][[:digit:]]*" >/dev/null && disk=${p%%p[0-9]*}
  expr "$p" : ".*[hsv]d[[:alpha:]][[:digit:]][[:digit:]]*" >/dev/null && disk=${p%%[0-9]*}
  if [ -n "$disk" ]; then
    echo "$disk"
    return 0
  else
    echo "$1"
    return 1
  fi
}


# extract number from partition
# get_partnr partition
get_partnr(){
  [ -b "$1" ] || return 1
  echo "$1" | sed -e 's|/dev/[hsv]d[abcdefgh]||' -e 's|/dev/xvd[abcdefgh]||' \
                  -e 's|/dev/mmcblk[0-9]p||' -e 's|/dev/nvme0n[0-9]p||'
}


# fschuett
# extract disk device names from start.conf partition definitions
# get_disks
get_disks_startconf(){
  [ -s /start.conf ] || return
  local parts="$(grep -iw ^dev /start.conf | awk -F\= '{ print $2 }' | awk '{ print $1 }' )"
  local disks=
  for p in $parts; do
    if [ -z "$disks" ]; then
      disks="$(get_disk_from_partition "$p")"
    else
      disks="$disks $(get_disk_from_partition "$p")"
    fi
  done;
  disks="$(echo $disks|tr " " "\n" | sort -u)"
  echo "$disks"
  return 0
}


# tschmitt
# get disks from kernel
get_disks(){
  local i
  local disks
  if [ -d /dev/disk/by-path ]; then
    for i in $(ls -l /dev/disk/by-path | grep -v '\-part' | awk -F\> '{ print $2 }' | awk -F\/ '{ print $3 }'); do
      if [ -z "$disks" ]; then
        disks="/dev/$i"
      else
        disks="$disks /dev/$i"
      fi
    done
  # Fallback if disk by-path does not exist. This is caused by missing udev rules for excample in nvme files
  else
     for i in $(ls -l /dev/disk/by-id | grep -v '\-part' | awk -F\> '{ print $2 }' | awk -F\/ '{ print $3 }'); do
       if [ -z "$disks" ]; then
        disks="/dev/$i"
       else
        disks="$disks /dev/$i"
       fi
     done
  fi
  echo "$disks"

  return 0
}


# tschmitt
# fetch fstype from start.conf
# fstype_startconf dev
fstype_startconf(){
  local dev="$1"
  local type=""
  local section=""
  local param=""
  local tdev=""
  local pfound=0
  local dfound=0
  local line=""
  if [ ! -e /start.conf ]; then
    echo "Fatal! start.conf nicht gefunden!"
    return 1
  fi
  while read line; do
    section=`echo $line | awk '{ print $1 }' | tr A-Z a-z`
    [ "$section" = "[partition]" ] && pfound=1
    if [ "$pfound" = 1 ]; then
      param=`echo $line | awk '{ print $1 }' | tr A-Z a-z`
      if [ "$param" = "dev" ]; then
        tdev=`echo $line | awk -F= '{ print $2 }' | awk '{ print $1 }'`
        if [ "$tdev" = "$dev" ]; then
          dfound=1
        else
          pfound=0; dfound=0; type=""
        fi
      fi
      if [ "$param" = "fstype" ]; then
        type=`echo $line | awk -F= '{ print $2 }' | awk '{ print $1 }' | tr A-Z a-z`
      fi
      if [ "$dfound" = 1 -a -n "$type" ]; then
        echo "$type"
        return 0
      fi
    fi
  done </start.conf
  return 1
}

# get partitionlabel from start.conf
# partlabel_startconf partition
partlabel_startconf(){
  [ -s /start.conf ] || return
  local part="$1"
  local line=""
  local dev=""
  local label=""
  grep -i ^[dl][ea][vb] /start.conf | awk -F\= '{ print $1 " " $2 }' | awk '{ print $1 " " $2 }' | while read line; do
    echo "$line" | grep -qi ^dev && dev="$(echo "$line" | awk '{ print $2 }')"
    echo "$line" | grep -qi ^label && label="$(echo "$line" | awk '{ print $2 }')"
    if [ -n "$dev" -a -n "$label" ]; then
      if [ "$dev" = "$part" ]; then
        echo "$label"
        return
      fi
      dev="" ; label=""
    fi
  done
}

# print_partlabel partition
print_partlabel(){
  [ -e /dev/disk/by-label ] || return
  local label="$(partlabel_startconf "$1")"
  [ -z "$label" ] && return
  ls -l /dev/disk/by-label/ | grep -qw "$label" && echo "$label"
}

# prints device name according to partition label
# print_realdev label
print_realdev(){
  [ -e /dev/disk/by-label ] || return
  local label="$1"
  [ -z "$label" ] && return
  local devname="$(ls -l /dev/disk/by-label/ | grep -w "$label" | awk -F\/ '{ print $3 }')"
  [ -n "$devname" ] && echo "/dev/$devname"
}

# label_allpartitions
label_allpartitions(){
  echo "Writing partition labels:" | tee -a /tmp/linbo.log
  local dev=""
  local line=""
  local label=""
  local RC=0
  grep -i ^dev /start.conf | awk -F\= '{print $2}' | awk '{print $1}' | sort -u | while read dev; do
    label="$(partlabel_startconf "$dev")"
    if [ ! -b "$dev" ]; then
      echo "$dev is not a block device!"
      RC=1
      continue
    fi
    if [ -n "$label" ]; then
      msg="Partition $dev --> Label $label ... "
      if mk_label "$dev" "$(fstype_startconf "$dev")" "$label" 2>&1 | tee -a /tmp/linbo.log; then
        echo "$msg OK!" | tee -a /tmp/linbo.log
      else
        echo "$msg Failed!" | tee -a /tmp/linbo.log
        RC=1
      fi
    fi
  done
  # issue 85
  [ -n "$UDEVADM" ] && "$UDEVADM" trigger
  [ -e /dev/disk/by-label ] || echo "No partition labels found!" | tee -a /tmp/linbo.log
  sendlog
  return "$RC"
}

# mountpart partition destdir [readonly]
mountpart(){
  local type="$(fstype $1)"
  [ -z "$type" ] && return 1
  local partition="$1"
  local destdir="$2"
  local ro
  [ "$3" = "-r" ] && ro=",ro"
  local options="noatime$ro"
  local mountcmd="mount -i -t $type"
  case "$type" in
    ntfs)
      options="$options,recover,remove_hiberfile,user_xattr,inherit,acl"
      mountcmd="mount.ntfs-3g"
      ;;
    vfat) ;;
    *) options="$options,acl,user_xattr" ;;
  esac
  # umount partition first if it is already mounted
  if grep -q ^"$partition $destdir" /proc/mounts; then
    umount $destdir
  fi
  $mountcmd -o $options $partition $destdir
  # check success
  local RC="1"
  grep -q ^"$partition $destdir" /proc/mounts && RC="0"
  # second try (do ntfsfix before in case of ntfs rw mount)
  if [ "$RC" != "0" -a "$type" = "ntfs" ]; then
    if [ -z "$ro" ]; then
      echo "Windows partition seems in bad shape. Try ntfsfix to solve this issue."
      ntfsfix "$partition"
    fi
    $mountcmd -o $options $partition $destdir
  # second try with default options for other filesystems
  elif [ "$RC" != "0" ]; then
    $mountcmd $partition $destdir
  fi
  # check success again
  grep -q ^"$partition $destdir" /proc/mounts && RC="0"
  return "$RC"
}

# Return true if cache is NFS- or SAMBA-Share
remote_cache(){
  case "$1" in *:*|*//*|*\\*|*\\\\*) return 0 ;; esac
  return 1
}

# mklabel partition fstype label
mk_label(){
  local partition="$1"
  local fstype="$2"
  local label="$3"
  local RC=0
  case "$fstype" in
    swap) mkswap -L "$label" "$partition" || RC=1 ;;
    ext2|ext3|ext4) e2label "$partition" "$label" || RC=1 ;;
    [Nn][Tt][Ff][Ss]*) ntfslabel -f "$partition" "$label" || RC=1 ;;
    *[Ff][Aa][Tt]*) fatlabel "$partition" "$label" || RC=1 ;;
    *) return 1 ;;
  esac
  return $RC
}

# format partition fstype label
format(){
  #echo -n "format " ;  printargs "$@"
  local partition="$1"
  local fstype="$2"
  local label="$3"
  local fcmd
  local RC
  if [ -n "$label" ]; then
    case "$fstype" in
      swap|ext2|ext3|ext4|[Nn][Tt][Ff][Ss]*) label="-L $label" ;;
      *[Ff][Aa][Tt]*) label="-n $label" ;;
      *) ;;
    esac
  fi
  case "$fstype" in
    [Ss][Ww][Aa][Pp]) fcmd="mkswap $label $partition" ;;
    [Rr][Ee][Ii][Ss][Ee][Rr][Ff][Ss]) fcmd="mkreiserfs $label -f -f $partition" ;;
    [Ee][Xx][Tt][234]) fcmd="mkfs.$fstype -F $label $partition" ;;
    [Nn][Tt][Ff][Ss]) fcmd="mkfs.ntfs $label -Q $partition" ;;
    *[Ff][Aa][Tt]*) fcmd="mkdosfs $label -F 32 $partition" ;;
    *) return 1 ;;
  esac
  echo -n "Formatting $partition with $fstype ..."
  [ -d "$partition" ] || sleep 5
  $fcmd 2>> /tmp/linbo.log 1>> /tmp/linbo.log ; RC="$?"
  if [ "$RC" != "0" ]; then
    echo -n " Partition is not yet ready - trying again ..."
    sleep 2
    $fcmd 2>> /tmp/linbo.log 1>> /tmp/linbo.log ; RC="$?"
  fi
  if [ "$RC" = "0" ]; then
    echo " OK!"
    # issue 85
    [ -n "$label" -a -n "$UDEVADM" ] && "$UDEVADM" trigger
    # install linbo and grub in cache
    local cachedev="$(cachedev)"
    if [ "$cachedev" = "$partition" ]; then
      rm -f /tmp/.gui.done
      rm -f /tmp/.update.done
      rm -f /tmp/.grub-install
      rm -f /tmp/.prepare_grub
      update "$(serverip)" "$cachedev"
      linbo_update_gui
      mk_boot
      if mountcache "$cachedev"; then
        echo "Saving start.conf in cache."
        cp /start.conf /cache
        # save hostname for offline use
        if [ -s /tmp/network.ok ]; then
          source /tmp/network.ok
          local FQDN="${hostname}.${domain}"
          echo "Saving hostname $FQDN in cache."
          echo "$FQDN" > /cache/hostname
        fi
      fi
    fi
  else
    echo " Failed!"
  fi
  return "$RC"
}

# mountcache partition [options]
mountcache(){
  local RC=1
  [ -n "$1" ] || return 1
  export CACHE_PARTITION="$1"
  # Avoid duplicate mounts by just preparing read/write mode
  local mount_opts="$(grep " /cache " /proc/mounts | awk '{ print $4 }')"
  if [ -n "$mount_opts" ]; then
    local RW=""
    echo "$mount_opts" | grep -q ".*rw.*" && RW="true"
    case "$2" in
      -r|-o\ *ro*) [ -n "$RW" ] && mount -o remount,ro /cache 2>> /tmp/linbo.log ; RC=0 ;;
      *) [ -n "$RW" ] || mount -o remount,rw /cache 2>> /tmp/linbo.log ; RC="$?" ;;
    esac
    return "$RC"
  fi
  case "$1" in
    *:*) # NFS
      local server="${1%%:*}"
      local dir="${1##*:}"
      echo "Mounte /cache per NFS von $1..."
      # -o nolock is EXTREMELY important here, otherwise mount.nfs will timeout waiting for
      # local portmap
      mount $2 -t nfs -o nolock,rsize=8192,wsize=8192,hard,intr "$1" /cache 2>> /tmp/linbo.log
      RC="$?"
      ;;
    \\\\*\\*|//*/*) # CIFS/SAMBA
      local server="${1%\\*}";  server="${server%/*}"; server="${server#\\\\}"; server="${server#//}"
      echo "Mounte /cache per SAMBA/CIFS von $1..."
      # unix extensions have to be disabled
      echo 0 > /proc/fs/cifs/LinuxExtensionsEnabled 2>/dev/null
      # mount.cifs (3) pays attention to $PASSWD
      # this does not work: $RSYNC_PASSWORD is not available and mount.cifs does not pay attention to $PASSWD
      #export PASSWD="$RSYNC_PASSWORD"
      #mount $2 -t cifs -o username=linbo,nolock "$1" /cache 2>/dev/null
      # temporary workaround for password
      [ -s /tmp/linbo.passwd ] && PASSWD="$(cat /tmp/linbo.passwd 2>/dev/null)"
      [ -z "$PASSWD" -a -s /tmp/rsyncd.secrets ] && PASSWD="$(grep ^linbo /tmp/rsyncd.secrets | awk -F\: '{ print $2 }' 2>/dev/null)"
      mount $2 -t cifs -o username=linbo,password="$PASSWD",nolock "$1" /cache 2>> /tmp/linbo.log
      RC="$?"
      if [ "$RC" != "0" ]; then
        echo "Zugriff auf $1 als Benutzer \"linbo\" mit Authentifizierung klappt nicht."
        mount $2 -t cifs -o nolock,guest,sec=none "$1" /cache 2>> /tmp/linbo.log
        RC="$?"
        if [ "$RC" != "0" ]; then
          echo "Zugriff als \"Gast\" klappt auch nicht."
        fi
      fi
      ;;
    /dev/*) # local cache
      echo "Mounte Cache-Partition $1 ..."
      mountpart "$1" /cache $2 2>> /tmp/linbo.log ; RC="$?"
      ;;
    *) # Yet unknown
      echo "Unbekannte Quelle fuer LINBO-Cache: $1" >&2
      ;;
  esac
  [ "$RC" = "0" ] || echo "Mounten von $1 nach /cache fehlgeschlagen!" >&2
  return "$RC"
}

killalltorrents(){
  local WAIT=5
  # check for running torrents and kill them if any
  if [ -n "`ps w | grep ctorrent | grep -v grep`" ]; then
    echo "Stoppe Torrents ..."
    killall -9 ctorrent 2>/dev/null
    sleep "$WAIT"
    [ -n "`ps w | grep ctorrent | grep -v grep`" ] && sleep "$WAIT"
  fi
}

# convert all units to MiB and ensure partability by 2048
convert_size(){
  local unit="$(echo $1 | sed 's|[^a-zA-Z]*||g')"
  local size="$(echo ${1/$unit} | awk -F\[,.] '{ print $1 }')"
  local unit="$(echo $unit | tr A-Z a-z | head -c1)"
  case "$unit" in
    k) size=$(( $size / 2048 * 2 )) ;;
    m) size=$(( $size / 2 * 2 )) ;;
    g) size=$(( $size * 1024 )) ;;
    t) size=$(( $size * 1024 * 1024 )) ;;
    *) return 1 ;;
  esac
  echo $size
}

# partition with parted, invoked by partition() for each disk
# args: table
mk_parted(){
  local table="$1"
  [ -s "$table" ] || return 1
  local disk="/dev/$(basename "$table")"
  [ -b "$disk" ] || return 1
  local lastnr="$(grep -c ^"$disk" "$table")"
  local dev
  local label
  local start
  local partstart
  local end
  local partend
  local extend
  local extpartend
  local size
  local unit="MiB"
  local id
  local fstype
  local partname
  local partflag
  local disklabel="msdos"
  local parttype="primary"
  local bootable
  local RC=0
  local CMD="parted -s -a opt $disk mkpart"
  # efi system -> gpt label
  systemtype | grep -qi efi && disklabel="gpt"
  echo "Creating new $disklabel partition table on $disk."
  # first overwrite mbr
  dd if=/dev/zero of=$disk bs=512 count=1 || RC="1"
  # second create partition label
  parted -s "$disk" mklabel "$disklabel" || RC="1"

  local n=0
  echo "partition label size id fstype bootable"
  while read dev label size id fstype bootable; do
    n=$(( n + 1 ))
    echo "$n: $dev $label $size $id $fstype $bootable"
    [ "$fstype" = "-" ] && fstype=""
    [ "$label" = "-" ] && label=""
    partname="" ; partflag=""

    # begin of first partition
    if [ $n -eq 1 ]; then
      start=1
    else
      if [ "$parttype" = "extended" -o "$parttype" = "logical" ]; then
        parttype="logical"
        # add 1 MiB to logical partition start position
        start=$(( $end + 1 ))
      else
        # start of next partition is the end of the partition before
        start=$end
      fi
    fi
    partstart=$start$unit

    # handle size if not set
    if [ "$size" = "-" ]; then
      partend="100%"
      extpartend="$partend"
    else
      isinteger "$size" && size="$size"k
      size="$(convert_size $size)"
      # don't increase the end counter in case of extended partition
      case "$id" in
        5|05) extend=$(( $start + $size )) ; extpartend=$extend$unit ;;
        * ) end=$(( $start + $size )) ; partend=$end$unit ;;
      esac
    fi

    # handle partition name
    if [ -n "$label" -a "$disklabel" = "gpt" ]; then
      partname="$label"
    else
      partname="$parttype"
    fi

    # handle last logical partition if size was not set and size for extended was set
    [ "$n" = "$lastnr" -a "$parttype" = "logical" -a "$partend" = "100%" -a -n "$extend" ] && partend=$extend$unit

    # create partitions
    case "$id" in
      c01|0c01) $CMD '"Microsoft reserved partition"' $partstart $partend || RC=1 ; partflag="msftres" ;;
      5|05)
        parttype="extended"
        $CMD $parttype $partstart $extpartend || RC=1
        if [ "$RC" = "0" ]; then
          # correct parted's idea of the extended partition id
          echo -e "t\n$n\n5\nw\n" | fdisk "$disk" 2>> /tmp/linbo.log 1>> /tmp/linbo.log || RC=1
        fi
        ;;
      6|06|e|0e) $CMD $partname fat16 $partstart $partend || RC=1 ;;
      7|07)
        if [ "$disklabel" = "gpt" ]; then
          $CMD '"Basic data partition"' NTFS $partstart $partend || RC=1
          partflag="msftdata"
        else
          $CMD $partname NTFS $partstart $partend || RC=1
        fi
        ;;
      b|0b|c|0c) $CMD $partname fat32 $partstart $partend || RC=1 ;;
      ef)
        if [ "$disklabel" = "gpt" ]; then
          $CMD '"EFI system partition"' fat32 $partstart $partend || RC=1
          partflag="boot"
        else
          $CMD $partname fat32 $partstart $partend || RC=1
          if [ "$RC" = "0" ]; then
            # correct parted's idea of the efi partition id on msdos disklabel
            echo -e "t\n$n\nef\nw\n" | fdisk "$disk" 2>> /tmp/linbo.log 1>> /tmp/linbo.log || RC=1
          fi
        fi
        ;;
      82) $CMD $partname linux-swap $partstart $partend || RC=1 ;;
      83) $CMD $partname $fstype $partstart $partend || RC=1 ;;
      *) $CMD $partname $partstart $partend || RC=1 ;;
    esac

    # set bootable flag
    if [ "$bootable" = "yes" ]; then
      if [ "$disklabel" = "msdos" ]; then
        echo -e "a\n$n\nw\n" | fdisk "$disk" 2>> /tmp/linbo.log 1>> /tmp/linbo.log || RC=1
      else
        # note: with gpt disklabel only one partition can own the bootable
        # flag, so the last one wins if multiple boot flags were set
        parted -s "$disk" set $n boot on || RC="1"
      fi
    fi

    # set other flags
    if [ -n "$partflag" ]; then
      parted -s "$disk" set $n $partflag on || RC="1"
    fi

    # format partition
    if [ -z "$NOFORMAT" -a -n "$fstype" ]; then
      format "$dev" "$fstype" "$label" || RC="1"
    fi

  done < "$table"

  if [ "$RC" = "0" ]; then
    echo "Finished partitioning of $disk successfully!"
  else
    echo "Failed to partition $disk! For details see $(hostname)_linbo.log."
  fi
  return "$RC"
}

# partitions defined in start.conf
# if NOFORMAT is set, partitions are not formatted
partition(){
  [ -s /start.conf ] || return 1
  killalltorrents
  #echo -n "partition " ;  printargs "$@"
  # umount /cache if mounted
  if cat /proc/mounts | grep -q /cache; then
    cd /
    if ! umount /cache &>/dev/null; then
      umount -l /cache &>/dev/null
      sleep "$WAIT"
      if cat /proc/mounts | grep -q /cache; then
        echo "Kann /cache nicht unmounten." >&2
        return 1
      fi
    fi
  fi

  # collect partition infos from start.conf and write them to table
  local dev
  local label
  local size
  local id
  local fstype
  local bootable
  local line
  local table="/tmp/partitions"
  local RC="0"
  rm -f "$table"
  grep -v '^$\|^\s*\#' /start.conf | awk -F\# '{ print $1 }' | sed -e 's| ||g' -e 's|[ \t]||' | tr A-Z a-z | while read line; do
    if echo "$line" | grep -q ^'\['; then
      if [ -n "$dev" ]; then
        if [ -z "$label" ]; then
          label="-"
        else
          # to ensure label is not lowered
          label="$(partlabel_startconf $dev)"
        fi
        [ -z "$fstype" ] && fstype="-"
        [ -z "$size" ] && size="-"
        [ -z "$bootable" ] && bootable="-"
        echo "$dev $label $size $id $fstype $bootable" >> "$table"
      fi
      dev=""; label=""; id=""; fstype=""; size=""; bootable=""
      continue
    fi
    case "$line" in dev=*|label=*|id=*|fstype=*|size=*|bootable=*) eval "$line" ;; esac
  done

  # get all disks from start.conf
  local disks="$(get_disks_startconf)"
  local disk
  local diskname
  # sort table by disks and partitions
  for disk in $disks; do
    diskname="${disk#\/dev\/}"
    grep ^"$disk" "$table" | sort > "/tmp/$diskname"
    mk_parted "/tmp/$diskname" || RC="1"
  done
  rm -f /tmp/.gui.done
  rm -f /tmp/.update.done
  rm -f /tmp/.grub-install
  rm -f /tmp/.prepare_grub
  return "$RC"
}

# print efi partition
print_efipart(){
  # test for efi system
  [ -d /sys/firmware/efi ] || return 1
  [ -s /start.conf ] || return 1
  local dev
  local id
  local label
  local line
  grep -v '^$\|^\s*\#' /start.conf | awk -F\# '{ print $1 }' | sed -e 's| ||g' -e 's|[ \t]||' | tr A-Z a-z | while read line; do
    if echo "$line" | grep -q ^'\['; then
      if [ "$id" = "ef" ]; then
        echo "$dev"
        return 0
      fi
      dev=""; id=""; label=""
      continue
    fi
    case "$line" in dev=*|id=*|label=*) eval "$line" ;; esac
  done
}

# print_grubpart partition
print_grubpart(){
  local partition="$1"
  [ -b "$partition" ] || return 1
  local partnr="$(get_partnr "$partition")"
  case "$partition" in
    /dev/mmcblk*) local disknr="$(echo "$partition" | sed 's|/dev/mmcblk\([0-9]\)p[1-9]|\1|')" ;;
    /dev/nvme0n*)
      local disknr="$(echo "$partition" | sed 's|/dev/nvme0n\([0-9]\)p[1-9]|\1|')"
      disknr=$(( $disknr - 1 ))
      ;;
    *)
      local diskchr="$(printf "$(echo $partition | sed 's|/dev/*[hsv]d\([a-z]\)[0-9]|\1|')")"
      local ord="$(LC_CTYPE=C printf '%d' "'$diskchr")"
      local disknr=$(( $ord - 97 ))
      ;;
  esac
  echo "(hd${disknr},${partnr})"
}

# print efi bootnr of given item
# print_efi_bootnr item efiout
print_efi_bootnr(){
  local item="$1"
  local efiout="$2"
  [ -z "$item" ] && return 1
  if [ -s "$efiout" ]; then
    local bootnr="$(grep -iw "$item" "$efiout" | head -1 | awk -F\* '{ print $1 }' | sed 's|^Boot||')"
  else
    local bootnr="$(efibootmgr | grep -iw "$item" | head -1 | awk -F\* '{ print $1 }' | sed 's|^Boot||')"
  fi
  if [ -n "$bootnr" ]; then
    echo "$bootnr"
  else
    return 1
  fi
}

# create efi boot entry
# create_efiboot label efipart
create_efiboot(){
  # return if entry exists
  efibootmgr | grep ^Boot[0-9] | awk -F\* '{ print $2 }' | grep -qiw " $1" && return 0
  local label="$1"
  local efipart="$2"
  local efipartnr="$(get_partnr "$efipart")"
  local efidisk="$(get_disk_from_partition "$efipart")"
  local efiloader
  local bits
  case "$label" in
    *[Ww][Ii][Nn][Dd][Oo][Ww][Ss]*) efiloader="\\EFI\\Microsoft\\Boot\\bootmgfw.efi" ;;
    grub) efiloader="\\EFI\\grub\\grubx64.efi" ;;
    *) echo "Unknown efiloader: $efiloader." ; return 1 ;;
  esac
  if efibootmgr --create --disk "$efidisk" --part "$efipartnr" --loader "$efiloader" --label "$label" 2>> /tmp/linbo.log 1>> /tmp/linbo.log; then
    echo "EFI boot entry for $label successfully created."
  else
    echo "Failed to create EFI boot entry for $label."
    return 1
  fi
}

# set_efibootnext: creates efi bootnext entry
# args: bootloaderid
set_efibootnext(){
  local bootloaderid="$1"
  local RC="0"
  forcegrub && bootloaderid="grub"
  # get the bootnr
  local bootnextnr="$(print_efi_bootnr "$bootloaderid")"
  if [ -n "$bootnextnr" ]; then
    if efibootmgr --bootnext "$bootnextnr" 2>> /tmp/linbo.log 1>> /tmp/linbo.log; then
      echo "EFI bootnext for $bootloaderid has been set to $bootnextnr."
    else
      echo "Failed to set boot no. for $bootloaderid to $bootnextnr."
      RC="1"
    fi
  else
    echo "Failed to get boot no. for $bootloaderid."
    RC="1"
  fi
  return "$RC"
}

# set_efibootorder: set the boot order to local,network
set_efibootorder(){
  local efiout="/tmp/efiout"
  efibootmgr | grep ^Boot | grep -vi ipv6 > "$efiout"
  local i
  local nr
  local RC="0"
  local bootorder
  # fix bootnext in case of KVM virtualization
  if dmesg | grep -qw KVM; then
    local bootnextnr="$(grep -i ^bootnext "$efiout" | awk '{ print $2 }')"
    [ -n "$bootnextnr" ] && bootorder="$bootnextnr"
  fi
  # searchstrings for grub (local boot) and efi network devices
  for i in grub ipv4 pxev4 "pxe ip4" "efi network" "usb nic" "onboard nic"; do
    nr="$(print_efi_bootnr "$i" "$efiout")"
    [ -z "$nr" ] && continue
    if [ -n "$bootorder" ]; then
      bootorder="$bootorder,$nr"
    else
      bootorder="$nr"
    fi
  done
  if [ -n "$bootorder" ]; then
    if efibootmgr --bootorder "$bootorder" 2>> /tmp/linbo.log 1>> /tmp/linbo.log; then
      echo "EFI bootorder has been successfully set."
    else
      echo "Failed to set EFI bootorder."
      RC="1"
    fi
  fi
  # remove dups
  efibootmgr -D || RC="1"
  return "$RC"
}

# repair_efi: sets efi configuration into a proper state
# args: efipart
repair_efi(){
  local doneflag="/tmp/.repair_efi"
  [ -e "$doneflag" ] && return 0
  local efipart="$1"
  local efiout="/tmp/efiout"
  local startflag="/tmp/.start"
  local line
  local item
  local FOUND
  local bootnr
  # first remove redundant entries, keep entries with lower number
  efibootmgr | grep ^Boot[0-9] | sort -r > "$efiout" || return 1
  # read in the unique boot entries and test for multiple occurances of the same item
  awk -F\* '{ print $2 }' "$efiout" | sort -u | while read item; do
    [ -z "$item" ] && continue
    line=""
    FOUND=""
    # delete redundant entries
    grep "$item" "$efiout" | while read line; do
      if [ -z "$FOUND" ]; then
        FOUND="yes"
        continue
      else
        bootnr="$(echo "$line" | awk -F\* '{ print $1 }' | sed 's|Boot||')"
        efibootmgr --bootnum "$bootnr" --delete-bootnum 2>> /tmp/linbo.log 1>> /tmp/linbo.log || return 1
      fi
    done
  done
  # create grub entry if missing
  create_efiboot grub "$efipart" || return 1
  # set bootorder
  if [ ! -e "$startflag" ]; then
    set_efibootorder || return 1
  fi
  touch "$doneflag"
}

# write_devicemap devicemap
# write grub device.map file
write_devicemap() {
  [ -z "$1" ] && return 1
  local devicemap="$1"
  local disk
  local n=0
  rm -f "$devicemap"
  # iterate through all disks found by kernel
  for disk in $(get_disks); do
    echo "(hd${n}) $disk" >> "$devicemap"
    n=$(( $n + 1 ))
  done
  [ -s "$devicemap" ] || return 1
}

# mk_winefiboot: restore and install windows efi boot files
# args: partition efipart bootloaderid
mk_winefiboot(){
  local partition="$1"
  local doneflag="/tmp/.mk_winefiboot.$(basename "$partition")"
  [ -e "$doneflag" ] && return 0
  local efipart="$2"
  local bootloaderid="$3"
  local RC="0"
  local win_bootdir="$(ls -d /mnt/[Ee][Ff][Ii]/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]/[Bb][Oo][Oo][Tt] 2> /dev/null)"
  # restore bcd from old bios boot dir
  if [ -n "$win_bootdir" ]; then
    # restore bcd and efiboot files on efi partition
    local win_bcd="$(ls "$win_bootdir"/[Bb][Cc][Dd] 2> /dev/null)"
    if [ -n "$win_bcd" ]; then
      local win_efidir="$(ls -d /cache/boot/efi/[Ee][Ff][Ii]/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]/[Bb][Oo][Oo][Tt] 2> /dev/null)"
      if [ -z "$win_efidir" ]; then
        win_efidir="/cache/boot/efi/EFI/Microsoft/Boot"
        mkdir -p "$win_efidir"
      fi
      # copy whole windows efi stuff to efi partition
      echo "Restoring windows bootfiles on EFI partition."
      rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -r "$win_bootdir/" "$win_efidir/"
    fi
  else
    echo "Failed to restore windows EFI bootfiles."
    RC="1"
  fi
  # create efi bootloader entry if missing
  create_efiboot "$bootloaderid" "$efipart" || RC="1"
  [ "$RC" = "0" ] && touch "$doneflag"
  return "$RC"
}

# mk_linefiboot: prepares linux os for efi boot
# args: partition grubdisk efipart bootloaderid
mk_linefiboot(){
  [ -d /mnt/boot/grub ] || return 1
  local partition="$1"
  local doneflag="/tmp/.mk_linefiboot.$(basename "$partition")"
  [ -e "$doneflag" ] && return 0
  local grubdisk="$2"
  local efipart="$3"
  local bootloaderid="$4"
  local RC="0"
  mkdir -p /mnt/boot/efi
  mount "$efipart" /mnt/boot/efi || return 1
  mkdir -p /mnt/boot/efi/EFI
  grub-install --root-directory=/mnt --bootloader-id="$bootloaderid" "$grubdisk" 2>> /tmp/linbo.log || RC="1"
  umount /mnt/boot/efi
  [ "$RC" = "0" ] && touch "$doneflag"
  return "$RC"
}

# mk_efiboot: if returns 1 a reboot via grub will be initiated, othwerwise reboot via efi directly
# args: efipart partition grubdisk
mk_efiboot(){
  local efipart="$1"
  local partition="$2"
  local grubdisk="$3"
  local startflag="/tmp/.start"
  local bootloaderid
  local doneflag="/tmp/.grub-install"
  # repare efi configuration
  repair_efi "$efipart" || return 1
  # restore windows efi boot files
  local RC="0"
  if [ "$(fstype $partition)" = "ntfs" ]; then
    bootloaderid="Windows Boot Manager"
    mk_winefiboot "$partition" "$efipart" "$bootloaderid" || RC="1"
  else # assume linux system
    bootloaderid="$(osname "$partition")"
    if [ -n "$bootloaderid" ]; then
      if ! mk_linefiboot "$partition" "$grubdisk" "$efipart" "$bootloaderid"; then
        echo "Failed to update linux EFI boot configuration."
        RC="1"
      fi
    fi
  fi
  # install default efi boot file
  local grubefi="/boot/efi/EFI/grub/grubx64.efi"
  if [ -s "$grubefi" ]; then
    local efibootdir="$(ls -d /boot/efi/EFI/B[Oo][Oo][Tt] 2>/dev/null)"
    [ -z "$efibootdir" ] && efibootdir="/boot/efi/EFI/BOOT"
    local bootefi="$(ls $efibootdir/[Bb][Oo][Oo][Tt][Xx]64.[Ee][Ff][Ii] 2>/dev/null)"
    [ -z "$bootefi" ] && bootefi="$efibootdir/BOOTX64.EFI"
    mkdir -p "$efibootdir"
    if ! rsync --skip-compress="$RSYNC_SKIP_COMPRESS" "$grubefi" "$bootefi"; then
      echo "Failed to restore EFI standard boot."
      RC="1"
    else
      echo "Successfully restored efi standard boot."
    fi
  fi
  # set efi bootnext entry if invoked by start()
  if [ -e "$startflag" -a -n "$bootloaderid" ]; then
    set_efibootnext "$bootloaderid" || RC="1"
    # set bootorder
    set_efibootorder || RC="1"
    # cause another grub-install
    [ "$RC" = "0" ] && rm -f "$doneflag"
  fi
  [ "$RC" = "1" ] && echo "Failed to write EFI boot configuration."
  # force grub reboot if forcegrub kerneloption is set
  forcegrub && RC="1"
  return "$RC"
}

# mk_grubboot partition grubenv kernel initrd append
# prepare for grub boot after reboot
mk_grubboot(){
  local partition="$1"
  local grubenv="$2"
  local KERNEL="$3"
  [ -z "$KERNEL" ] && return 0
  local doneflag="/tmp/.mk_grubboot.$(basename "$partition")"
  [ -e "$doneflag" ] && return 0
  local INITRD="$4"
  local APPEND="$5"
  local RC="0"
  # reboot partition is the partition where the os is installed
  local REBOOT="$(print_grubpart $partition)"
  local LABEL="$(print_partlabel $partition)"
  # save reboot informations in grubenv
  echo "Schreibe Reboot-Informationen nach $grubenv."
  grub-editenv "$grubenv" set reboot_grub="$REBOOT" || RC="1"
  grub-editenv "$grubenv" set reboot_label="$LABEL" || RC="1"
  if [ "$KERNEL" != "[Aa][Uu][Tt][Oo]" ]; then
    [ "${KERNEL:0:1}" = "/" ] || KERNEL="/$KERNEL"
    grub-editenv "$grubenv" set reboot_kernel="$KERNEL" || RC="1"
    if [ -n "$INITRD" ]; then
      [ "${INITRD:0:1}" = "/" ] || INITRD="/$INITRD"
      grub-editenv "$grubenv" set reboot_initrd="$INITRD" || RC="1"
    fi
    if [ -n "$APPEND" ]; then
      grub-editenv "$grubenv" set reboot_append="$APPEND" || RC="1"
    fi
  fi
  [ "$RC" = "0" ] && touch "$doneflag"
  return "$RC"
}

# prepare_reboot: prepares filesystem for reboot to os
# args: grubdisk partition grubenv kernel initrd append efipart
prepare_reboot(){
  local grubdisk="$1"
  local partition="$2"
  local grubenv="$3"
  local KERNEL="${4#/}"
  local INITRD="${5#/}"
  local APPEND="$6"
  local efipart="$7"
  local efiboot="false"
  local noefibootmgr="$(kerneloptions | grep -iw noefibootmgr)"
  remote_cache "$(cachedev)" || local localcache="yes"
  if [ -z "$noefibootmgr" -a -n "$efipart" ]; then
    mk_efiboot "$efipart" "$partition" "$grubdisk" && efiboot="true"
  fi
  if [ "$efiboot" = "false" ]; then
    if [ -n "$localcache" ]; then
      mk_grubboot "$partition" "$grubenv" "$KERNEL" "$INITRD" "$APPEND" || return 1
    else
      # create reboot grubenv file on server
      local rebootstr="$(print_grubpart $partition)#${KERNEL}#${INITRD}#${APPEND}#.reboot"
      rsync --skip-compress="$RSYNC_SKIP_COMPRESS" $(serverip)::linbo/"$rebootstr" /tmp 2>"$TMP" || true
    fi
  fi
}

# prepare_grub: install and reset grub files in cache
# args: grubdir grubenv grubsharedir
prepare_grub(){
  local doneflag="/tmp/.prepare_grub"
  [ -e "$doneflag" ] && return 0
  echo "Providing grub environment in cache ..."
  local grubdir="$1"
  local grubenv="$2"
  local grubsharedir="$3"
  local RC=0
  [ -e "$grubdir" ] || mkdir -p "$grubdir"
  # write grub device.map file
  #echo -n " * Writing device.map ... "
  write_devicemap "$grubdir/device.map" || RC=1
  #echo "Ok!"
  # provide default grub.cfg with current append params on localmode
  if localmode; then
    echo -n " * Providing grub environment in localmode ... "
    local kopts="$(kerneloptions)"
    [ -z "$kopts" ] && kopts="splash quiet localboot"
    sed -e "s|linux \$linbo_kernel .*|linux \$linbo_kernel $(kerneloptions) localboot|g" "$grubsharedir/grub.cfg" > "$grubdir/grub.cfg" || RC=1
    echo "Ok!"
  fi
  # provide unicode font
  echo " * Providing grub environment ... "
  rsync "$grubsharedir/unicode.pf2" "$grubdir/unicode.pf2" || RC=1
  #echo "Ok!"
  # reset grubenv
  if [ -s "$grubenv" ]; then
    for i in reboot reboot_kernel reboot_initrd reboot_append; do
      grub-editenv "$grubenv" unset "$i" || RC="1"
    done
  else
    grub-editenv "$grubenv" create || RC="1"
  fi
  #echo "Ok!"
  [ "$RC" = "0" ] && touch "$doneflag"
  return "$RC"
}

# mk_boot: configure boot stuff
# args: partition kernel initrd append
mk_boot(){
  local KERNEL="${2#/}"
  local INITRD="${3#/}"
  local APPEND="$4"
  local efipart="$(print_efipart)"
  local partition="$1"
  remote_cache "$(cachedev)" || local localcache="yes"
  # get disk for grub install, use always the first disk from start.conf
  local grubdisk="$(get_disk_from_partition $(grep -iw ^dev /start.conf | awk -F\= '{ print $2 }' | awk '{ print $1 }' | grep ^/dev | sort -u | head -1))"
  if [ ! -b "$grubdisk" ]; then
    echo "$grubdisk is not a block device!"
    return 1
  fi
  # mount efi partition
  if [ -n "$efipart" ]; then
    mkdir -p /cache/boot/efi
    mount "$efipart" /cache/boot/efi || return 1
    mkdir -p /cache/boot/efi/EFI
  fi
  # needed grub dirs
  local grubdir="/cache/boot/grub"
  local grubenv="$grubdir/grubenv"
  local grubsharedir="/usr/share/grub"
  local doneflag="/tmp/.grub-install"
  local RC="0"
  # prepare grub stuff
  if [ -n "$localcache" ]; then
    prepare_grub "$grubdir" "$grubenv" "$grubsharedir" || RC="1"
  fi
  # prepare reboot stuff
  if [ -n "$partition" ]; then
    prepare_reboot "$grubdisk" "$partition" "$grubenv" "$KERNEL" "$INITRD" "$APPEND" "$efipart" || RC="1"
  fi
  # install grub in mbr/efi
  if [ ! -e "$doneflag" -a -n "$localcache" ]; then
    echo -n "Installing GRUB in MBR/EFI of $grubdisk ... "
    grub-install --root-directory=/cache -s $grubdisk 2>> /tmp/linbo.log || RC="1"
    if [ "$RC" = "0" ]; then
      touch "$doneflag"
      echo "OK!"
    else
      echo "failed!"
    fi
  fi
  # umount efi partition if mounted
  if [ -n "$efipart" ]; then
    umount /cache/boot/efi || RC="1"
  fi
  return "$RC"
}

# download server file [important]
download(){
  local RC=1
  [ -n "$3" ] && echo "RSYNC Download $1 -> $2..."
  rm -f "$TMP"
  interruptible rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -HaLz --partial --progress "$1::linbo/$2" "$(basename $2)" 2>"$TMP"; RC="$?"
  if [ "$RC" != "0" ]; then
    # Delete incomplete/defective/non-existent file (maybe we should check for returncode=23 first?)
    rm -f "$2" 2>/dev/null
    if [ -n "$3" ]; then
      # Verbose error message if file was important
      cat "$TMP" >&2
      echo "Datei $2 konnte nicht heruntergeladen werden." >&2
    fi
  fi
  rm -f "$TMP"
  return "$RC"
}

# request macct file to invoke samba password hash ldap upload stuff on the server
# invoke_macct imagebase
invoke_macct(){
  [ -z "$1" ] && return 1
  local imagebase="$1"
  local i
  local imagemacct
  # get image filename from start.conf
  for i in qcow2 cloop; do
    if grep -i ^baseimage /start.conf | grep -q "${imagebase}.${i}"; then
      imagemacct="${imagebase}.${i}.macct"
      break
    fi
  done
  [ -z "$imagemacct" ] && return 1
  local serverip="$(grep -m1 ^linbo_server= /tmp/dhcp.log | awk -F\' '{ print $2 }')"
  [ -z "$serverip" ] && return 1
  echo "Initiating machine password update on server $serverip ..."
  download "$serverip" "$imagemacct"
}

# do_machinepw (not used)
# no args
# handle machine password stuff locally and on the server
do_machinepw(){
  local mpwfile="$(uuidgen).mpw"
  download "$(serverip)" "$mpwfile"
  local RC="0"
  if [ -s "$mpwfile" ]; then
    local machinepw="$(cat $mpwfile)"
    local srcdir="/linuxmuster-win"
    local tgtdir="/mnt$srcdir"
    sed -e "s|@@machinepw@@|$machinepw|" "$srcdir/set_machinepw.cmd.tpl" > "$tgtdir/set_machinepw.cmd" || RC="1"
    [ "$RC" = "0" ] && echo "Maschinenpasswort wurde gesetzt."
  else
    RC="1"
  fi
  rm -f "$mpwfile"
  return "$RC"
}

# update linuxmuster-win scripts and install start tasks
# update_win partition
# invoked by start() & syncl()
update_win(){
  local doneflag="/tmp/.update_win"
  [ -e "$doneflag" ] && return 0
  [ -b "$1" ] || return 1
  local RC="0"
  mkdir -p /mnt/linuxmuster-win
  # copy scripts to os rootdir
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -r /cache/linuxmuster-win/ /mnt/linuxmuster-win/ || RC="1"
  if [ "$RC" = "0" ]; then
    touch "$doneflag"
    # restrict access rights on certain files and folders on windows partition
    local partition="$1"
    local seclist
    local i
    local curdir="$(pwd)"
    cd /mnt
    for i in .linbo .guid.* Boot EFI linuxmuster-win; do
      [ -e "$i" ] && seclist="$seclist $i"
    done
    cd "$curdir"
    if [ -n "$seclist" ]; then
      sync
      umount /mnt 2>> /tmp/linbo.log
      for i in $seclist; do
        echo "Restrict access rights on $i:" | tee -a /tmp/linbo.log
        ntfssecaudit "$partition" 700 "$i" | tee -a /tmp/linbo.log
      done
      mountpart "$partition" /mnt 2>> /tmp/linbo.log
    fi
  fi
  return "$RC"
}

# start: start operating system
# args: boot root kernel initrd append cache
start(){
  echo -n "start " ;  printargs "$@"
  # if no kernel is given, do not start
  if [ -z "$3" ]; then
    echo "There is nothing to start!"
    return 1
  fi
  local INITRD
  local APPEND
  local partition="$2"
  local KERNEL="${3#/}"
  local i
  local warmstart
  for i in `cat /proc/cmdline`; do case "$i" in warmstart=*) eval $i ;; esac; done
  local label="$(print_partlabel "$partition")"
  local cachedev="$6"
  local mntpnt="/mnt"
  [ "$partition" = "$cachedev" ] && mntpnt="/cache"
  [ -d /sys/firmware/efi/efivars ] && local efi="true"
  local startflag="/tmp/.start"
  touch "$startflag"
  if mountpart "$partition" "$mntpnt" 2>> /tmp/linbo.log; then
    if [ -e "$mntpnt/$KERNEL" ]; then
      echo "Found kernel $KERNEL on partition $partition."
      INITRD="${4#/}"
      APPEND="$5"
      # add root to append string
      if [ -n "$label" ]; then
        APPEND="root=LABEL=$label $APPEND"
      else
        APPEND="root=$partition $APPEND"
      fi
      # no warmstart, if start partition is cache
      [ "$partition" = "$cachedev" ] && warmstart="no"
      # load kernel for later warmstart
      if [ -z "$warmstart" ]; then
        kexec --type="bzImage64" --append="$APPEND" --initrd="/mnt/$INITRD" --load "/mnt/$KERNEL" || warmstart="no"
      fi
    else
      echo "No kernel $KERNEL on partition $partition. Using \"auto\"."
      KERNEL="auto"
      warmstart="no"
    fi
    # install/update grub/efi stuff if cache is mounted
    if mountcache "$cachedev"; then
      # prepare reboot if no warmstart
      [ -z "$warmstart" ] || mk_boot "$partition" "$KERNEL" "$INITRD" "$APPEND" | tee -a /tmp/linbo.log
      # update linuxmuster-win scripts and install start tasks
      [ "$(fstype "$partition")" = "ntfs" -a -d /cache/linuxmuster-win ] && update_win "$partition" | tee -a /tmp/linbo.log
    fi
    # pre start stuff
    if [ -s /mnt/.linbo ]; then
      local imagebase="$(cat /mnt/.linbo)"
      local prestart="${imagebase}.prestart"
      if ! localmode; then
        download "$(serverip)" "images/$imagebase/$prestart"
        [ -e "$prestart" ] || download "$(serverip)" "$prestart"
        if [ -e "$prestart" ]; then
          mv "$prestart" /cache
        else
          rm -f "/cache/$prestart"
        fi
      fi
      [ -s "/cache/$prestart" ] && source "/cache/$prestart"
    fi
  else
    echo "Unable to mount operating system partition $partition." >&2
    umount /mnt 2>> /tmp/linbo.log
    mountcache "$cachedev" -r
    return 1
  fi
  # sets machine password on server
  invoke_macct "$imagebase"
  # kill torrents if any
  #killalltorrents
  sync
  umount /mnt 2>> /tmp/linbo.log
  sendlog
  # start os directly or reboot into it
  if [ -z "$warmstart" ]; then
    kexec -e
  else
    reboot -f
  fi
}

# return partition size in kilobytes
# arg: partition
get_partition_size(){
  local part="$1"
  # fix wrong invokation by linbo_gui
  [ "$part" = "/dev/mmcblkp" ] && part="/dev/mmcblk0"
  [ "$part" = "/dev/nvmenp" ] && part="/dev/nvme0n1"
  if [ -L "$part" ]; then
    local partsrc="$(stat "$part" | grep File | awk -F\' '{ print $4}')"
    if ! echo "$partsrc" | grep -q '/dev/'; then
      partsrc="/dev/$partsrc"
    fi
    [ -b "$partsrc" ] && part="$partsrc"
  fi
  local size="$(grep -w "${part#\/dev\/}" /proc/partitions | awk '{ print $3 }' 2>> /tmp/linbo.log)"
  if [ -n "$size" ]; then
    echo "$size"
    return 0
  else
    return 1
  fi
}

# echo file size in bytes
get_filesize(){
  ls -l "$1" 2>/dev/null | awk '{print $5}' 2>/dev/null
  return $?
}

# save_efi_bcd targetdir efipart
# saves the windows efi file to os partition
save_efi_bcd(){
  local targetdir="$1"
  local efipart="$2"
  local efimnt="/cache/boot/efi"
  mkdir -p "$efimnt"
  mount "$efipart" "$efimnt" || return 1
  local sourcedir="$(ls -d "$efimnt"/[Ee][Ff][Ii]/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]/[Bb][Oo][Oo][Tt] 2> /dev/null)"
  if [ -z "$sourcedir" ]; then
    echo "$sourcedir not found. Cannot copy windows efi bootfiles to $targetdir."
    umount "$efimnt" || umount -l "$efimnt"
    return 1
  fi
  echo "Copying windows efi bootfiles from $sourcedir to $targetdir."
  mkdir -p "$targetdir"
  local RC=0
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -r "$sourcedir/" "$targetdir/" || RC="1"
  umount "$efimnt" || umount -l "$efimnt"
  [ "$RC" = "1" ] && echo "Copying of windows efi bootfiles failed!"
  return "$RC"
}

# print_guid device
# print uuid of a partition or a disk
print_guid(){
  if [ ! -b "$1" ]; then
    echo "$1 is not a block device!"
    return 1
  fi
  local i
  # get uuid with blkid
  for i in `blkid "$1"`; do
    case "$i" in
      PARTUUID=*|PTUUID=*)
        echo "$i" | awk -F\" '{print $2}' | tr a-z A-Z
        break
      ;;
    esac
  done
}

# set_guid device guid
# sets gpt uuid of a partition (works only with efi)
set_guid(){
  [ -z "$1" -a -z "$2" ] && return 1
  if [ ! -b "$1" ]; then
    echo "$1 is not a block device!"
    return 1
  fi
  # get device data
  local i
  local PARTUUID
  local PTUUID
  local device
  local guid
  # get current guid and check if it matches already
  for i in `blkid "$1"`; do
    case "$i" in
      PARTUUID=*|PTUUID=*)
        guid="$(echo "$i" | awk -F \" '{print $2}')"
        if [ "$(echo $guid | tr A-Z a-z)" = "$(echo $2 | tr A-Z a-z)" ]; then
          echo "UUID $guid of $1 matches already. Doing nothing."
          return 0
        fi
        eval $i
        device="$1"
        guid="$2"
        break
      ;;
    esac
  done
  # disk or a partition
  if [ -n "$PARTUUID" ]; then
    # partition
    echo "Restoring partition UUID $guid of $device."
    local disk="$(get_disk_from_partition "${device}")"
    local partnr="$(get_partnr "$device")"
    echo -e "x\nc\n$partnr\n$guid\nw\nY\n" | gdisk "$disk" 2>&1
  elif [ -n "$PTUUID" ]; then
    # disk
    echo "Restoring disk UUID $guid of $device."
    echo -e "x\ng\n$guid\nw\nY\n" | gdisk "$device" 2>&1
  else
    echo "Unknown device $device!" | tee -a /tmp/image.log
    return 1
  fi
  blkid "$device" | grep -qi "$guid" || return 1
}

# prepare_fs directory partition
# Removes all files from ${RSYNC_EXCLUDE} and saves win7 boot configuration in
# the root directory of the os.
prepare_fs(){
  (
    # remove excluded files
    cd "$1" || return 1
    local i=""
    for i in ${RSYNC_EXCLUDE}; do # Expand patterns
      if [ -e "$i" ]; then
        echo "Entferne $i."
        rm -rf "$i"
      fi
    done
    # save win7 bcd & mbr
    local targetdir
    # in case of efi save the windows efi files
    local efipart="$(print_efipart)"
    if [ -n "$efipart" ]; then
      # save partition & disk uuids
      echo "Saving partition guids."
      print_guid "$efipart" > /mnt/.guid.efi
      print_guid "$2" > /mnt/.guid.part
      local disk="$(get_disk_from_partition "$2")"
      print_guid "$disk" > /mnt/.guid.disk
      if [ "$(fstype $2)" = "ntfs" ]; then
        targetdir="$(ls -d [Ee][Ff][Ii]/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]/[[Bb][Oo][Oo][Tt] 2> /dev/null)"
        [ -z "$targetdir" ] && targetdir="EFI/Microsoft/Boot"
        save_efi_bcd "$targetdir" "$efipart" | tee -a /tmp/linbo_image.log
      fi
    else
      targetdir="$(ls -d [Bb][Oo][Oo][Tt] 2> /dev/null)"
    fi
    if [ -n "$targetdir" ]; then
      local bcd="$(ls $targetdir/[Bb][Cc][Dd] 2> /dev/null)"
      local group="$(hostgroup)"
      if [ -n "$bcd" -a -n "$group" ]; then
        echo "Saving windows bcd for group $group."
        # BCD group specific and partition specific on efi systems
        if [ -n "$efipart" ]; then
          cp -f "$bcd" "$bcd"."$group"."$(basename "$2")"
        else
          cp -f "$bcd" "$bcd"."$group"
        fi
        # boot sector backup group specific
        # delete obsolete mbr backups
        rm -f "$targetdir/winmbr.$group" "$targetdir/win7mbr.$group" "$targetdir/winmbr446.$group" "$targetdir/bsvbr.$group"
        local disk="$(get_disk_from_partition "$2")"
        local bsmbr="$targetdir/bsmbr.$group"
        # save bootloader sectors
        echo "Saving bootloader sectors for group $group."
        dd if="$disk" of="$bsmbr" bs=446 count=1 2>> /tmp/linbo.log
        # in case of gpt partition label (deprecated, see #25 & #26)
#        if fdisk -l "$disk" | grep -q "GPT"; then
#          echo "Saving gpt label for group $group."
#          local gptlabel="$targetdir/gptlabel.$group"
#          dd if="$disk" of="$gptlabel" bs=512 count=34 2>> /tmp/linbo.log
#        fi
        # ntfs partition id
        echo "Saving ntfs id."
        local ntfsid="$targetdir/ntfs.id"
        dd if="$2" of="$ntfsid" bs=8 count=1 skip=9 2>> /tmp/linbo.log
      fi
    fi
  )
}


# mk_qcow2 rootdev imagename
mk_qcow2(){
  local rootdev="$1"
  local imagename="$2"
  echo "## $(date) : Starting creation of $imagename." | tee -a /tmp/image.log
  # kill torrent process for this image
  local pid="$(ps w | grep ctorrent | grep "$imagename.torrent" | grep -v grep | awk '{ print $1 }')"
  [ -n "$pid" ] && kill "$pid"
  # remove torrent files
  [ -e "/cache/$imagename.torrent" ] && rm -f "/cache/$imagename.torrent"
  [ -e "/cache/$imagename.complete" ] && rm -f "/cache/$imagename.complete"
  local RC=1
  local size="$(get_partition_size $rootdev)"
  if [ -z "$size" ]; then
    echo "Cannot get size of $rootdev!" | tee -a /tmp/image.log
    return 1
  fi
  set -o pipefail
  mountpart "$rootdev" /mnt -w | tee -a /tmp/linbo.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Cannot mount $rootdev!"
    return "$RC"
  fi
  echo "Preparing partition $rootdev (size=${size}K) for compression..." | tee -a /tmp/image.log
  set -o pipefail
  prepare_fs /mnt "$rootdev" | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Cannot prepare $rootdev!"
    return "$RC"
  fi
  echo "Filling up partition with zeroes..." | tee -a /tmp/image.log
  # Create nulled files of size 1GB, should work on any FS.
  local count=0
  while true; do
    # tschmitt: log errors to image.log
    interruptible dd if=/dev/zero of="/mnt/zero$count.tmp" bs=1024k count=1000 2>>/tmp/image.log || break
    [ -s "/mnt/zero$count.tmp" ] || break
    let count++
    echo "$(du -ch /mnt/zero*.tmp | tail -1 | awk '{ print $1 }') zeroed ... " | tee -a /tmp/image.log
  done
  # remove excluded files
  grep -v ^# /etc/rsync.exclude | while read line; do
    [ -z "$line" ] && continue
    [ "${line:0:1}" = " " ] && continue
    rm -rf /mnt/$line
  done
  # Sync is asynchronous, unless started twice at least.
  sync ; sync ; sync
  rm -f /mnt/zero*.tmp
  umount /mnt || umount -l /mnt
  echo "Starting compression of $rootdev -> $imagefile (full partition, ${size}K)." | tee -a /tmp/image.log
  echo "qemu-img convert -p -c -f raw -O qcow2 $rootdev $imagefile" | tee -a /tmp/image.log
  set -o pipefail
  interruptible qemu-img convert -p -c -f raw -O qcow2 "$rootdev" "$imagefile" | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Creation of $imagefile failed. :(" | tee -a /tmp/image.log
    return "$RC"
  fi
  set -o pipefail
  mountpart "$rootdev" /mnt -w | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Mounting of $rootdev failed. :(" | tee -a /tmp/image.log
    return "$RC"
  fi
  local imagename="${imagefile%.qcow2}"
  echo "$imagename" > /mnt/.linbo
  umount /mnt || umount -l /mnt
  # create info file
  local imgsize="$(get_filesize $imagefile)"
  mk_info "$imagefile" "$rootdev"
  echo "Done." | tee -a /tmp/image.log
  ls -l "$rootdev"
  # create torrent file
  echo "Creating torrent files ..." | tee -a /tmp/image.log
  touch "$imagefile".complete
  local serverip="$(grep -i ^server /start.conf | awk -F\= '{ print $2 }' | awk '{ print $1 }')"
  ctorrent -t -u http://"$serverip":6969/announce -s "$imagefile".torrent "$imagefile" | tee -a /tmp/image.log
  echo "## $(date) : Creation of $imagefile finished." | tee -a /tmp/image.log
  return "$RC"
}


# check_status partition imagefile:
# returns true if mountable & contains a version of the archive.
check_status(){
  local RC=1
  local base="${2##*/}"
  base="${base%.[CcQq][LlCc][Oo][OoWw][Pp2]}"
  echo "## $(date) : Check status of $1 using $2." | tee -a /tmp/linbo.log
  mountpart "$1" /mnt -r 2>> /tmp/linbo.log || return $?
  [ -s /mnt/.linbo ] && case "$(cat /mnt/.linbo 2>/dev/null)" in *$base*) RC=0 ;; esac
  umount /mnt || umount -l /mnt
  # [ "$RC" = "0" ] && echo "Enthaelt schon eine Version von $2."
  return "$RC"
}

# update_status partition imagefile:
# Add information about installed archives to partition
update_status(){
  local base="${2##*/}"
  base="${base%.[CcQq][LlCc][Oo][OoWw][Pp2]}"
  echo "## $(date) : Update status of $1 using $2." | tee -a /tmp/linbo.log
  mountpart "$1" /mnt -w 2>> /tmp/linbo.log || return $?
  echo "$base" > /mnt/.linbo
  #sync; sync; sleep 1
  umount /mnt || umount -l /mnt
  return 0
}


# differential/Synced
# sync_image imagefile targetdev
sync_image(){
  echo "## $(date) : Starting sync of $1 to $2." | tee -a /tmp/image.log
  local imagefile="$1"
  local targetdev="$2"
  local RC
  set -o pipefail
  mountpart "$targetdev" /mnt -w | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Cannot mount $targetdev!"
    return "$RC"
  fi
  local ROPTS="-HaAX"
  [ "$(fstype "$targetdev")" = "vfat" ] && ROPTS="-rt"
  # mount qcow2 image as network block device
  set -o pipefail
  qemu-nbd -r --connect /dev/nbd0 "$imagefile" | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Connection to $imagefile failed!" | tee -a /tmp/image.log
    qemu-nbd --disconnect /dev/nbd0 >> /tmp/image.log
    return "$RC"
  fi
  # wait a few seconds after qemu-nbd connect attempt
  sleep 3
  mkdir -p /image
  if ! mountpart /dev/nbd0 /image -r; then
    echo "Mounting $imagefile failed!" | tee -a /tmp/image.log
    qemu-nbd --disconnect /dev/nbd0 >> /tmp/image.log
    return "$RC"
  fi
  # sync image
  echo "Syncing ... please wait ..."
  set -o pipefail
  interruptible rsync --skip-compress="$RSYNC_SKIP_COMPRESS" "$ROPTS" --exclude="/.linbo" --exclude-from="/etc/rsync.exclude" --delete --delete-excluded --log-file=/tmp/image.log --log-file-format="" /image/ /mnt 2>&1 | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  umount /image
  if [ "$RC" != "0" ]; then
    echo "Image sync of $imagefile to $targetdev failed!" | tee -a /tmp/image.log
  fi
  qemu-nbd --disconnect /dev/nbd0 >> /tmp/image.log
  sync; sync; sleep 1
  umount /mnt || umount -l /mnt
  [ "$RC" = "0" ] && update_status "$2" "$1"
  echo "## $(date) : Sync from $1 finished." | tee -a /tmp/image.log
  return "$RC"
}


# full copy
# cp_image imagefile targetdev
cp_image(){
  echo "## $(date) : Starting full restore of $2 using $1." | tee -a /tmp/image.log
  local RC=1
  local imagefile="$1"
  local imagetype="${imagefile##*.}"
  local targetdev="$2"
  if [ ! -s "$imagefile" ]; then
    echo "Error with $imagefile"
    return "$RC"
  fi
  if [ ! -b "$targetdev" ]; then
    echo "$targetdev is no block device!"
    return "$RC"
  fi
  # check sizes
  qemu-nbd -r --connect /dev/nbd0 "$imagefile" || return "$RC"
  # wait a few seconds after qemu-nbd connect attempt
  sleep 3
  local s1="$(get_partition_size /dev/nbd0)"
  local s2="$(get_partition_size $targetdev)"
  if [ "$s1" -gt "$s2" ] 2>/dev/null; then
    echo "Error: $imagefile (${s1}K) is bigger than partition $targetdev (${s2}K)" >&2 | tee -a /tmp/image.log
    qemu-nbd --disconnect /dev/nbd0 >> /tmp/image.log
    return 1
  fi
  # restore
  qemu-nbd --disconnect /dev/nbd0 >> /tmp/image.log
  set -o pipefail
  interruptible qemu-img convert -p -f "$imagetype" -O raw "$imagefile" "$targetdev" | tee -a /tmp/image.log
  RC="$?"
  set +o pipefail
  if [ "$RC" != "0" ]; then
    echo "Restore with $imagefile failed!"
    return "$RC"
  fi
  # check if resize is necessary
  if [ "$s2" -gt "$s1" ]; then
    echo "Trying to resize filesystem on $targetdev." | tee -a /tmp/image.log
    local fstype="$(fstype_startconf "$targetdev")"
    case "$fstype" in
      ntfs) echo -e "y\n" | ntfsresize "$targetdev" | tee -a /tmp/image.log ;;
      ext4)
        e2fsck -f "$targetdev" | tee -a /tmp/image.log
        resize2fs -f "$targetdev" | tee -a /tmp/image.log
        ;;
      *) ;;
    esac
  fi
  update_status "$targetdev" "$imagefile" ; RC="$?"
  echo "## $(date) : Full restore from $imagefile finished." | tee -a /tmp/image.log
  return "$RC"
}


# restore imagefile targetdev [force]
restore(){
  echo -n "restore " ;  printargs "$@"
  local RC=1
  local imagefile="$1"
  local imagetype="${imagefile##*.}"
  local targetdev="$2"
  local force="$3"
  local fstype="$(fstype_startconf "$targetdev")"
  local label="$(print_partlabel "$targetdev")"
  echo "Unpacking: $imagefile -> $targetdev"
  check_status "$targetdev" "$imagefile" || force="force"
  if [ "$force" = "force" ]; then
    set -o pipefail
    format "$targetdev" "$fstype" "$label" | tee -a /tmp/linbo.log ; RC="$?"
    set +o pipefail
    if [ "$RC" != "0" ]; then
      echo "Formatting of $targetdev failed!"
      return "$RC"
    fi
    # do file sync in case of ext4 filesytem
    [ "$fstype" = "ext4" ] && force=""
  fi
  if [ "$force" = "force" ]; then
    echo "Forcing partition clone ..."
    cp_image "$imagefile" "$targetdev" ; RC="$?"
  else
    echo "File sync ..."
    sync_image "$imagefile" "$targetdev" ; RC="$?"
  fi
  if [ "$RC" = "0" ]; then
    echo "Done."
  else
    echo "Error!"
  fi
  return "$RC"
}

# tschmitt
# patch fstab with root partition and root fstype: patch_fstab rootdev
patch_fstab(){
  echo -n "patch_fstab " ;  printargs "$@"
  local rootdev="$1"
  local line=""
  local found=""
  local fstype_mount=""
  local fstype_fstab=""
  local mntpnt=""
  local changed=""
  local rootdev_fstab=""
  local options=""
  local dump=""
  local pass=""
  [ -z "$rootdev" ] && return 1
  [ -e "$rootdev" ] || return 1
  [ -e /tmp/fstab ] && rm -f /tmp/fstab
  while read line; do
    if [ -n "$line" -a "${line:0:1}" != "#" ]; then
      mntpnt="$(echo "$line" | awk '{ print $2 }')"
      if [ "$mntpnt" = "/" -a -z "$found" ]; then
        found=yes
        rootdev_fstab="$(echo "$line" | awk '{ print $1 }')"
        [ -z "$rootdev_fstab" ] && return 1
        fstype_fstab="$(echo "$line" | awk '{ print $3 }')"
        [ -z "$fstype_fstab" ] && return 1
        options="$(echo "$line" | awk '{ print $4 }')"
        [ -z "$options" ] && return 1
        dump="$(echo "$line" | awk '{ print $5 }')"
        [ -z "$dump" ] && return 1
        pass="$(echo "$line" | awk '{ print $6 }')"
        [ -z "$pass" ] && return 1
        if [ "$rootdev_fstab" != "$rootdev" ]; then
          # change root partition if necessary
          echo "Setze Rootpartition: $rootdev."
          rootdev_fstab="$rootdev"
          line="$rootdev_fstab $mntpnt $fstype_fstab $options $dump $pass"
          changed=yes
        fi # rootdev
        # check for changed filesytem type if partition was formatted
        fstype_mount="$(cat /proc/mounts | grep "^$rootdev" | awk '{ print $3 }')"
        [ -z "$fstype_mount" ] && return 1
        if [ "$fstype_fstab" != "$fstype_mount" ]; then
          # change filesystem
          echo "Setze Dateisystem: $fstype_mount."
          fstype_fstab="$fstype_mount"
          line="$rootdev_fstab $mntpnt $fstype_fstab $options $dump $pass"
          changed=yes
        fi # fstype
      fi # mntpnt
    fi # line
    echo "$line" >> /tmp/fstab
  done </mnt/etc/fstab # reading fstab
  if [ -n "$changed" ]; then
    mv -f /mnt/etc/fstab /mnt/etc/fstab.bak
    mv -f /tmp/fstab /mnt/etc
  fi
}

# restore windows activation tokens
restore_winact(){
  # get image name
  [ -s  /mnt/.linbo ] && local imagename="$(cat /mnt/.linbo)"
  # if an image is not yet created do nothing
  if [ -z "$imagename" ]; then
    echo "Ueberspringe Reaktivierung, System ist unsynchronisiert."
    return
  fi
  local archive
  local tarchive
  local i
  # get mac address
  local mac="$(mac | tr a-z A-Z)"
  # without linbo server
  if localmode || [ -z "$mac" ] || [ "$mac" = "OFFLINE" ]; then
    tarchive="$(cd /cache && ls *.$imagename.winact.tar.gz 2> /dev/null)"
    # get mac address from archive name
    for i in $tarchive; do
      mac="$(echo $i | awk -F\. '{ print $1 }')"
      if ifconfig -a | grep -q "$mac"; then
        archive="$i"
        break
      fi
    done
  else # with linbo server
    archive="$mac.$imagename.winact.tar.gz"
    # get server ip address
    local serverip="$(grep ^linbo_server /tmp/dhcp.log | tail -1 | awk -F\' '{ print $2 }')"
    echo -n "Fordere Reaktivierungs-Daten von $serverip an ... "
    # get token archive from linbo server
    rsync --skip-compress="$RSYNC_SKIP_COMPRESS" "$serverip"::linbo/winact/"$archive" /cache &> /dev/null
    if [ -s "/cache/$archive" ]; then
      echo "OK!"
    else
      echo "ueberspringe Reaktivierung, keine Daten!"
      return
    fi
    # request windows/office productkeys
    local keyfile="$(ifconfig -a | md5sum | awk '{ print $1 }').winkey"
    rsync --skip-compress="$RSYNC_SKIP_COMPRESS" "$serverip"::linbo/winact/"$keyfile" /cache &> /dev/null
    [ -s "/cache/$keyfile" ] && source "/cache/$keyfile"
    # create windows key batchfile
    local cache_batchfile="/cache/$imagename.winact.cmd"
    # remove old batchfile
    rm -f "$cache_batchfile"
    # create new one if keys are provided
    if [ -n "$winkey" ]; then
      echo "cscript.exe %SystemRoot%\\System32\\slmgr.vbs -ipk $winkey" > "$cache_batchfile"
    fi
    # add office key handling to batchfile if office token is in archive
    if gunzip -c "/cache/$archive" | tar -t | grep -qi office 2> /dev/null; then
      if [ -n "$officekey" ]; then
        # get path to ospp.vbs
        local ospp="$(ls /mnt/[Pp][Rr][Oo][Gg][Rr][Aa][Mm]\ [Ff][Ii][Ll][Ee][Ss]*/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]\ [Oo][Ff][Ff][Ii][Cc][Ee]/[Oo][Ff][Ff][Ii][Cc][Ee]*/[Oo][Ss][Pp][Pp].[Vv][Bb][Ss] 2> /dev/null)"
        if [ -n "$ospp" ]; then
          # compute windows path to office installation dir
          local ospp_win_path="$(echo "$ospp" | sed 's|/mnt/|%SystemDrive%\\|' | sed 's|/|\\|g' )"
          # write office activations commands to batchfile
          echo "cscript.exe \"$ospp_win_path\" /inpkey:$officekey" >> "$cache_batchfile"
          echo "cscript.exe \"$ospp_win_path\" /act" >> "$cache_batchfile"
        fi
      fi
    fi
    rm -f "$keyfile"
  fi # localmode
  # copy reactivation batchfile to windows partition
  if [ -s "$cache_batchfile" ]; then
    local win_batchfile="/mnt/linuxmuster-win/winact.cmd"
    if [ -n "$winkey" -a -n "$officekey" ]; then
      local keymsg="Windows- und Office-Keys"
    elif [ -n "$winkey" ]; then
      local keymsg="Windows-Key"
    else
      local keymsg="Office-Key"
    fi
    echo "Erstelle Reaktivierungskript mit $keymsg in $win_batchfile."
    dos2unix "$cache_batchfile"
    cp "$cache_batchfile" "$win_batchfile"
  else # no keys, no batchfile
    echo "Keine Produktkeys verfuegbar, erstelle kein Reaktivierungskript."
  fi
  if [ -n "$archive" -a -s "/cache/$archive" ]; then
    echo "Stelle Windows-Aktivierungstokens wieder her."
    if ! tar xf "/cache/$archive" -C /; then
      echo "Fehler beim Entpacken von $archive!"
      return 1
    fi
  fi
}


# print windows version
winver(){
  local hive="$(ls -1d /mnt/[Ww][Ii][Nn][Dd][Oo][Ww][Ss]/[Ss][Yy][Ss][Tt][Ee][Mm]32/[Cc][Oo][Nn][Ff][Ii][Gg]/[Ss][Oo][Ff][Tt][Ww][Aa][Rr][Ee] 2> /dev/null)"
  [ -z "$hive" ] && return 1
  local winverhex="$(echo -e "cd \Microsoft\Windows NT\CurrentVersion\ncat CurrentMajorVersionNumber\nq\n" | reged -e "$hive" | grep ^0x 2> /dev/null)"
  [ -z "$winverhex" ] && return 1
  printf "%d\n" "$winverhex"
}


# syncl cachedev baseimage image bootdev rootdev kernel initrd append [force]
syncl(){
  local RC="1"
  local patchfile=""
  local postsync=""
  local rootdev="$5"
  local disk="$(get_disk_from_partition "$rootdev")"
  local group="$(hostgroup)"
  local bootdir
  local image="$2"
  local force="$9"
  local HOSTNAME
  local FQDN
  local efipart="$(print_efipart)"
  local partname="$(basename "$rootdev")"
  local guidfile
  local device
  local i

  # don't sync in that case
  if [ "$1" = "$rootdev" ]; then
    echo "Skipping local synchronisation. Image $image will be started direct from cache."
    return 0
  fi

  # begin syncing
  echo "syncl $@" | tee -a /tmp/linbo.log

  # mount cache and sync
  mountcache "$1" || return 1
  cd /cache
  # start syncing image
  restore "$image" "$rootdev" $force ; RC="$?"
  local imagename="${image%.*}"
  local imagetype="${image##*.}"
  if [ "$imagetype" = "cloop" ]; then
    patchfile="$image.reg"
    postsync="$image.postsync"
  else
    patchfile="$imagename.reg"
    postsync="$imagename.postsync"
  fi

  # mount os partition
  if [ "$RC" = "0" ]; then
    mountpart "$rootdev" /mnt -w 2>> /tmp/linbo.log ; RC="$?"
  fi
  # return on error
  if [ "$RC" != "0" ]; then
    echo "Cannot mount $rootdev!" | tee -a /tmp/linbo.log
    sendlog
    cd /
    return "$RC"
  fi

  # detect windows os
  [ -e /mnt/[Nn][Tt][Ll][Dd][Rr] -o -e /mnt/[Bb][Oo][Oo][Tt][Mm][Gg][Rr] -o -d /mnt/[Ww][Ii][Nn][Dd][Oo][Ww][Ss]/[Ss][Yy][Ss][Tt][Ee][Mm]32 ] && local is_win="yes"

  # get hostname
  if [ -s /tmp/network.ok ]; then
    source /tmp/network.ok
    FQDN="${hostname}.${domain}"
    HOSTNAME="$hostname"
  elif [ -s /cache/hostname ]; then
    FQDN="$(cat /cache/hostname)"
    HOSTNAME="$(echo "$FQDN" | awk -F \. '{ print $1 }')"
    [ "$FQDN" = "$HOSTNAME" ] && FQDN=""
  fi
  [ -z "$HOSTNAME" ] && HOSTNAME="$(hostname)"

  ## Prepare os filesystem, apply patches etc.

  # restore guids in case of efi/gpt partitions
  if [ -n "$efipart" ]; then
    echo "UEFI system found."
  else
    echo "BIOS system found."
  fi

  # windows stuff begin
  if [ -n "$is_win" ]; then

    # do registry patching for windows systems
    [ -s "$patchfile" ] && linbo_patch_registry "$patchfile" "$HOSTNAME" | tee /tmp/patch.log

    # manage windows boot files
    local bcd_backup

    # efi
    if [ -n "$efipart" ]; then
      # detect efi boot dir backup
      bootdir="$(ls -d /mnt/[Ee][Ff][Ii]/[Mm][Ii][Cc][Rr][Oo][Ss][Oo][ff][Tt]/[Bb][Oo][Oo][Tt] 2> /dev/null)"
      # create efi boot dir from bios boot stuff if not exists
      if [ -z "$bootdir" ]; then
        bootdir="/mnt/EFI/Microsoft/Boot"
        mkdir -p "$bootdir"
        local oldbootdir="$(ls -d /mnt/[Bb][Oo][Oo][Tt] 2> /dev/null)"
        if [ -n "$oldbootdir" ]; then
          cp -r "$oldbootdir"/* "$bootdir/"
        fi
        local srcdir="$(ls -d /mnt/[Ww][Ii][Nn][Dd][Oo][Ww][Ss]/[Bb][Oo][Oo][Tt]/[Ee][Ff][Ii] 2> /dev/null)"
        [ -n "$srcdir" ] && cp -r "$srcdir"/* "$bootdir/"
      fi
      bcd_backup="$bootdir"/BCD."$group"."$partname"
    else
      # bios
      bootdir="$(ls -d /mnt/[Bb][Oo][Oo][Tt])"
      bcd_backup="$bootdir"/BCD."$group"
    fi

    # restore bcd
    if [ -s "$bcd_backup" ]; then
      echo "Restoring windows bcd from $(basename "$bcd_backup")."
      cp -f "$bcd_backup" "$bootdir"/BCD
    fi

    # restore disk boot sector
    # detect old versions
    local bsmbr="$bootdir"/bsmbr."$group"
    local bsmbr_old="$bootdir"/winmbr446."$group"
    [ -e "$bsmbr_old" ] && mv "$bsmbr_old" "$bsmbr"
    [ -e "$bsmbr" ] || bsmbr="$bootdir"/winmbr."$group"
    [ -e "$bsmbr" ] || bsmbr="$bootdir"/win7mbr."$group"
    if [ -e "$bsmbr" ]; then
      echo "Restoring windows bootloader from $(basename "$bsmbr")" | tee -a /tmp/linbo.log
      case "$bsmbr" in
        *bsmbr.*)
          dd if="$bsmbr" of="$disk" bs=446 count=1 2>> /tmp/linbo.log
          ;;
        *winmbr.*)
          dd if="$bsmbr" of="$disk" bs=1 count=4 seek=440 2>> /tmp/linbo.log
          ;;
        *win7mbr.*)
          dd if="$bsmbr" of="$disk" bs=1 count=4 skip=440 2>> /tmp/linbo.log
          ;;
      esac
    fi

    # restore disk & partition uuids on efi systems
    if [ -n "$efipart" ]; then
      # restore old gptlabel
      local gptlabel="$bootdir"/gptlabel."$group"
      # only if no disk guid file exists
      if [ -s "$gptlabel" -a ! -s /mnt/.guid.disk ]; then
        echo "Saving current gpt label."
        local gptcurrent="/tmp/gptlabel.current"
        dd if="$disk" of="$gptcurrent" bs=512 count=34 2>> /tmp/linbo.log
        echo "Restoring old gpt label from $(basename "$gptlabel")." | tee -a /tmp/linbo.log
        dd if="$gptlabel" of="$disk" bs=512 count=34 2>> /tmp/linbo.log
        # get disk uuid from old gpt label
        print_guid "$disk" > /mnt/.guid.disk
        echo "Restoring current gpt label." | tee -a /tmp/linbo.log
        dd if="$gptcurrent" of="$disk" bs=512 count=34 2>> /tmp/linbo.log
      fi
      # move old guid file for os partition in place
      [ ! -s /mnt/.guid.part -a -s "/mnt/.guid.$partname" ] && mv "/mnt/.guid.$partname" /mnt/.guid.part
      # restore partition & disk guids from according files
      for i in disk efi part; do
        case "$i" in
          disk) device="$disk" ;;
          efi) device="$efipart" ;;
          part) device="$rootdev" ;;
        esac
        guidfile="/mnt/.guid.$i"
        [ -s "$guidfile" ] && set_guid "$device" "$(cat "$guidfile")" | tee -a /tmp/image.log
      done
    fi

    # restore ntfs id
    [ -e "$bootdir"/ntfs.id ] && local ntfsid="$(ls "$bootdir"/ntfs.id 2> /dev/null)"
    if [ -n "$ntfsid" -a -s "$ntfsid" ]; then
      echo "Restoring ntfs-id $(basename "$ntfsid")."
      dd if="$ntfsid" of="$rootdev" bs=8 count=1 seek=9 2>> /tmp/linbo.log
    fi

    # update linuxmuster-win scripts and restore windows activation
    if [ -d /cache/linuxmuster-win ]; then
      update_win "$rootdev" || RC="1"
      if [ "$RC" = "0" ]; then
        restore_winact || RC="1"
      fi
    fi

  fi # windows stuff end

  # linux stuff begin

  # grub efi
  if [ -n "$efipart" -a -d /mnt/boot/grub ]; then
    mkdir -p /mnt/boot/efi
    mount "$efipart" /mnt/boot/efi
    local i
    for i in /dev /dev/pts /proc /sys; do
      mount --bind "$i" /mnt"$i"
    done
    chroot /mnt update-grub
    for i in /sys /proc /dev/pts /dev; do
      umount /mnt"$i"
    done
    umount /mnt/boot/efi
  fi

  # hostname
  if [ -f /mnt/etc/hostname ]; then
    if [ -n "$HOSTNAME" ]; then
      echo "Setting hostname -> $HOSTNAME."
      echo "$HOSTNAME" > /mnt/etc/hostname
    fi
  fi

  # copy ssh keys
  if [ -d /mnt/etc/dropbear ]; then
    cp /etc/dropbear/* /mnt/etc/dropbear
    if [ -s /mnt/root/.ssh/authorized_keys ]; then
      local sshkey="$(cat /.ssh/authorized_keys)"
      grep -q "$sshkey" /mnt/root/.ssh/authorized_keys || cat /.ssh/authorized_keys >> /mnt/root/.ssh/authorized_keys
    else
      mkdir -p /mnt/root/.ssh
      cp /.ssh/authorized_keys /mnt/root/.ssh
    fi
    chmod 600 /mnt/root/.ssh/authorized_keys
  fi

  # patch dropbear config with port 2222 and disable password logins
  if [ -s /mnt/etc/default/dropbear ]; then
    sed -e 's|^NO_START=.*|NO_START=0|
            s|^DROPBEAR_EXTRA_ARGS=.*|DROPBEAR_EXTRA_ARGS=\"-s -g\"|
    s|^DROPBEAR_PORT=.*|DROPBEAR_PORT=2222|' -i /mnt/etc/default/dropbear
  fi

  # fstab
  [ -f /mnt/etc/fstab ] && patch_fstab "$rootdev"

  # linux stuff end

  # source postsync script
  [ -s "/cache/$postsync" ] && . "/cache/$postsync"

  # finally do minimal boot configuration
  mk_boot || RC=1

  # all done
  sync; sync; sleep 1
  umount /mnt || umount -l /mnt

  # restore partition labels
  label_allpartitions

  # log hosts image status
  if [ "$RC" = "0" ]; then
    local timestamp="$(getinfo /cache/$image.info timestamp)"
    log_image_status "$image" "$timestamp" applied
  fi

  sendlog
  cd / # ; mountcache "$1" -r
  return "$RC"
}

# create cachedev imagefile baseimagefile bootdev rootdev kernel initrd
create(){
  echo -n "create " ;  printargs "$@" | tee -a /tmp/image.log
  [ -z "$1" -o -z "$5" ] && return 1
  [ -z "$2" -a -z "$3" ] && return 1
  if [ -n "$2" -a -n "$3" ]; then
    if [ "$2" != "$3" ]; then
      echo "Differential images are currently not supported!"
      return 1
    fi
  fi
  local cachedev="$1"
  local imagefile="$2"
  local baseimagefile="$3"
  local rootdev="$5"
  if ! echo "$imagefile" | grep -q ".qcow2"; then
    echo "Only the creation of qcow2 images is currently supported!"
    return 1
  fi
  mountcache "$cachedev" || return 1
  if ! cache_writable; then
    echo "Cache partition is not writable!" | tee -a /tmp/image.log
    sendlog
    mountcache "$cachedev" -r
    return 1
  fi
  cd /cache
  local RC="1"
  echo "Creating image $imagefile of partition $rootdev ..." | tee -a /tmp/image.log
  set -o pipefail
  mk_qcow2 "$rootdev" "$imagefile"  | tee -a /tmp/image.log ; RC="$?"
  set +o pipefail
  [ "$RC" = "0" ] && echo "Done." || echo "Failed" | tee -a /tmp/image.log
  sendlog
  cd / ; mountcache "$1" -r
  return "$RC"
}

# getinfo file key
getinfo(){
  [ -f "$1" ] || return 1
  while read line; do
    local key="${line%%=*}"
    if [ "$key" = "$2" ]; then
      echo ${line#*=}
      return 0
    fi
  done <"$1"
  return 1
}

# write hosts image status to logfile
# usage (flag can be "applied" or empty): log_image_status image timestamp flag
log_image_status(){
  if [ "$3" = "applied" ]; then
    status="$(date +%Y%m%d%H%M) $3: $1 $2"
  else
    status="$2 created: $1 $2"
  fi
  echo "$status" | tee /tmp/image.status
  sendlog image.status
}

# mk_info imagefile rootdev - creates timestamp file
mk_info(){
  local imagefile="$1"
  local rootdev="$2"
  local partsize="$(get_partition_size "$rootdev")"
  local imagesize="$(get_filesize "$imagefile")"
  local timestamp="$(date +%Y%m%d%H%M)"
  log_image_status "$imagefile" "$timestamp"
  cat <<EOF > "$imagefile".info
["$imagefile" Info File]
timestamp="$timestamp"
image="$imagefile"
imagesize="$imagesize"
partition="$rootdev"
partitionsize="$partsize"
EOF
}

# get_multicast_server file
get_multicast_server(){
  local file=""
  local serverport=""
  local relax=""
  while read file serverport relax; do
    if [ "$file" = "$1" ]; then
      echo "${serverport%%:*}"
      return 0
    fi
  done </multicast.list
  return 1
}

# get_multicast_port file
get_multicast_port(){
  local file=""
  local serverport=""
  local relax=""
  while read file serverport relax; do
    if [ "$file" = "$1" ]; then
      echo "${serverport##*:}"
      return 0
    fi
  done </multicast.list
  return 1
}

# download_multicast server port file
download_multicast(){
  local interface="$(route -n | grep ^0.0.0.0 | awk '{print $NF}')"
  echo "MULTICAST Download $interface($1):$2 -> $3"
  echo "udp-receiver --log /tmp/image.log --nosync --nokbd --interface $interface --rcvbuf 4194304 --portbase $2 --file $3"
  interruptible udp-receiver --log /tmp/image.log --nosync --nokbd --interface "$interface" --rcvbuf 4194304 --portbase "$2" --file "$3" 2>&1 ; RC="$?"
  return "$RC"
}

# torrent_watchdog image timeout
torrent_watchdog(){
  local image="$1"
  local complete="$image".complete
  local torrent="$image".torrent
  local logfile=/tmp/"$image".log
  local timeout="$2"
  local line=""
  local line_old=""
  local int=10
  local RC=1
  local c=0
  while [ $c -lt $timeout ]; do
    sleep $int
    # check if torrent is complete
    [ -e "$complete" ] && { RC=0; break; }
    line="$(tail -1 "$logfile" | awk '{ print $3 }')"
    [ -z "$line_old" ] && line_old="$line"
    if [ "$line_old" = "$line" ]; then
      [ $c -eq 0 ] || echo -e "\nTorrent watchdog: download of $image stalls since $c seconds." >&2 | tee -a /tmp/image.log
      c=$(($c+$int))
    else
      line_old="$line"
      c=0
    fi
  done
  rm -f "$logfile"
  echo
  if [ "$RC" = "0" ]; then
    echo "Image $image downloaded successfully." | tee -a /tmp/image.log
  else
    ps w | grep -v grep | grep -q ctorrent && killall -9 ctorrent
    echo "Cancelled download of $image because of timeout." >&2 | tee -a /tmp/image.log
  fi
  return "$RC"
}

# download_torrent imagefile
download_torrent(){
  local imagefile="$1"
  local torrent="$imagefile".torrent
  local complete="$imagefile".complete
  local RC=1
  [ -e "$torrent" ] || return "$RC"
  local ip="$(ip)"
  [ -z "$ip" -o "$ip" = "OFFLINE" ] && return "$RC"
  # default values
  local SEEDHOURS=100000
  local MAXPEERS=100
  local MINPEERS=1
  local MAXUP
  local MAXDOWN
  local SLICESIZE=128
  local TIMEOUT=300
  local OPTIONS
  [ -e /torrent-client.conf ] && . /torrent-client.conf
  local pid="$(ps w | grep ctorrent | grep "$torrent" | grep -v grep | awk '{ print $1 }')"
  [ -n "$pid" ] && kill "$pid"
  local CTOPTS="-I $ip -m $MINPEERS -M $MAXPEERS -z $SLICESIZE"
  [ -n "$OPTIONS" ] && CTOPTS="$CTOPTS $OPTIONS"
  [ -n "$MAXUP" ] && CTOPTS="$CTOPTS -U $MAXUP"
  [ -n "$MAXDOWN" ] && CTOPTS="$CTOPTS -D $MAXDOWN"
  echo "Torrent options: $CTOPTS" >> /tmp/image.log
  echo "Starting torrent service for $imagefile." | tee -a /tmp/image.log
  local logfile=/tmp/"$imagefile".log
  if [ ! -e "$complete" ]; then
    rm -f "$imagefile" "$torrent".bf
    torrent_watchdog "$imagefile" "$TIMEOUT" &
    interruptible ctorrent -e 0 $CTOPTS -X "touch $complete" "$torrent" | tee -a "$logfile"
  fi
  # start seeder if download is complete
  if [ -e "$complete" ]; then
    RC=0
    ctorrent -e $SEEDHOURS $CTOPTS -f -d "$torrent"
  fi
  return "$RC"
}

# Download main file and supplementary files
# download_all server mainfile additional_files...
download_all(){
  local RC=0
  local server="$1"
  download "$server" "$2" important; RC="$?"
  if [ "$RC" != "0" ]; then
    rm -f "$2"
    return "$RC"
  fi
  shift; shift;
  local file=""
  for file in "$@"; do
    download "$server" "$file"
  done
  return "$RC"
}

# download_img_if_changed server imgagefile downloadtype
download_img_if_changed(){
  # do not execute in localmode
  localmode && return 0
  local server="$1"
  local imagefile="$2"
  local imagebase="$(basename "$imagefile" | sed 's/\(.*\)\..*/\1/')"
  local subdir="images/$imagebase/"
  local infofile="${imagefile}.info"
  local dltype="$3"
  [ -z "$dltype" ] && dltype="$(downloadtype)"
  [ -z "$dltype" ] && dltype="rsync"
  local DOWNLOAD
  # download image if info or image file is not there
  [ -s "$infofile" ] || DOWNLOAD="true"
  [ -s "$imagefile" ] || DOWNLOAD="true"
  # compare local and server image info files to know whether image download is needed
  if [ -z "$DOWNLOAD" ]; then
    # move info file
    mv -f "$infofile" "${infofile}.bak"
    # download infofile, first try from subdir
    if ! download "$server" "${subdir}${infofile}"; then
      download "$server" "$infofile" || return 1
      subdir=""
    fi
    # compare
    diff -q "$infofile" "${infofile}.bak" || DOWNLOAD="true"
    rm -f "${infofile}.bak"
  fi
  # check imagefile size to know whether image download is needed
  if [ -z "$DOWNLOAD" ]; then
    local fs1="$(getinfo "$infofile" imagesize | sed 's|\"||g')"
    local fs2="$(get_filesize "$imagefile")"
    if [ -z "$fs1" -o -z "$fs2" ]; then
      DOWNLOAD="true"
    elif [ "$fs1" != "$fs2" ]; then
      DOWNLOAD="true"
    fi
  fi
  # download other supplemental files
  download_all "$server" "${subdir}${imagefile}.desc" \
    "${subdir}${imagefile}.info" \
    "${subdir}${imagefile}.reg" \
    "${subdir}${imagefile}.postsync" \
    "${subdir}${imagebase}.reg" \
    "${subdir}${imagebase}.postsync"
  # if image file is unchanged compared to server version end here
  if [ -z "$DOWNLOAD" ]; then
    echo "$imagefile has not changed, nothing to do."
    # in case of downloadtype torrent, start seeding
    if [ "$dltype" = "torrent" ]; then
      [ -s "${imagefile}.torrent" ] || download "$server" "${subdir}${imagefile}.torrent"
      download_torrent "$imagefile"
    fi
    return 0
  fi
  # download image file
  local RC=0
  rm -f "$2".complete
  case "$dltype" in
    torrent)
      # remove old image and torrents before download starts
      rm -f "$2" "$2".torrent.bf
      # download torrent file
      download "$server" "${subdir}${imagefile}.torrent" important || RC="1"
      if [ "$RC" = "0" ]; then
        download_torrent "$imagefile" || RC="1"
      fi
      ;;
    multicast)
      if [ -s /multicast.list ]; then
        local MPORT="$(get_multicast_port "$imagefile")"
        if [ -n "$MPORT" ]; then
          download_multicast "$server" "$MPORT" "$imagefile" || RC="1"
        else
          echo "Cannot get multicast port, no multicast download possible." >&2
          RC=1
        fi
      else
        echo "multicast.list not found, no multicast download possible." >&2
        RC=1
      fi
      ;;
  esac
  # download per rsync also as a fallback if other download types failed
  if [ "$RC" != "0" -o "$dltype" = "rsync" ]; then
    RC="0"
    download "$server" "${subdir}${imagefile}" important || RC="1"
  fi
  return "$RC"
}

# Authenticate server user password share
authenticate(){
  local RC=1
  localmode ; RC="$?"
  if [ "$RC" = "1" ]; then
    export RSYNC_PASSWORD="$3"
    echo "Logging $2 in on $1..."
    rm -f "$TMP"
    rsync --skip-compress="$RSYNC_SKIP_COMPRESS" "$2@$1::linbo-upload" >/dev/null 2>"$TMP" ; RC="$?"
  elif [ -e /etc/linbo_passwd ]; then
    echo "Offline authentication ..."
    md5passwd="$(echo -n "$3" | md5sum | awk '{ print $1 }')"
    linbo_md5passwd="$(cat /etc/linbo_passwd)"
    if [ "$md5passwd" = "$linbo_md5passwd" ]; then
      RC=0
    else
      echo 'Does not match!' >"$TMP" ; RC=1
    fi
  else
    echo 'Unable to authenticate local!' >"$TMP" ; RC=1
  fi
  if [ "$RC" != "0" ]; then
    echo "Failed: $(cat "$TMP")" >&2
    echo "Wrong password or missing password file?" >&2
  else
    echo "Password matches."
    # temporary workaround for password
    echo -n "$RSYNC_PASSWORD" > /tmp/linbo.passwd
  fi
  rm -f "$TMP"
  return "$RC"
}

# upload server user password cache file
upload(){
  # do not execute in localmode
  localmode && return 0
  local server="$1"
  local user="$2"
  local pw="$3"
  local cache="$4"
  local file="$5"
  local filetype="${file##*.}"
  local RC=0
  local filelist
  local imagebase
  local subdir
  local i
  if remote_cache "$cache"; then
    echo "Cache $cache is not local, no upload for $file." | tee -a /tmp/linbo.log
    sendlog
    return 1
  fi
  # We may need this password for mountcache as well!
  export RSYNC_PASSWORD="$pw"
  mountcache "$cache" || return 1
  cd /cache
  if [ -s "$file" ]; then
    filelist="$file"
    # expand filelist in case of qcow2 file
    echo "### filetype: $filetype ###"
    if [ "$filetype" = "qcow2" ]; then
      imagebase="${file%.$filetype}"
      subdir="images/$imagebase/"
      for i in info desc torrent; do
        [ -s "${file}.${i}" ] && filelist="$filelist ${file}.${i}"
      done
    fi
    echo "Uploading $filelist to $server ..." | tee -a /tmp/linbo.log
    for i in $filelist; do
      interruptible rsync --skip-compress="$RSYNC_SKIP_COMPRESS" --log-file=/tmp/rsync.log --progress -Ha $RSYNC_PERMISSIONS --partial "$i" "$user@$server::linbo-upload/${subdir}${i}"
      # because return code is always 0 this is necessary
      grep -q "rsync error" /tmp/rsync.log && RC=1
      cat /tmp/rsync.log >> /tmp/linbo.log
      rm /tmp/rsync.log
      [ "$RC" = "0" ] || break
    done
  else
    RC=1
    echo "File $file does not exist." | tee -a /tmp/linbo.log
  fi
  if [ "$RC" = "0" ]; then
    echo "Successfully uploaded $filelist to $server." | tee -a /tmp/linbo.log
  else
    echo "Failed to upload $filelist to $server." | tee -a /tmp/linbo.log
  fi
  sendlog
  cd / ; mountcache "$cache" -r
  return "$RC"
}

# Sync from server
# syncr server cachedev baseimage image bootdev rootdev kernel initrd append [force]
syncr(){
  echo "syncr " ; printargs "$@"
  if remote_cache "$2"; then
    echo "Cache $2 is not local, skipping image update."
  else
    mountcache "$2" || return 1
    cd /cache
    local i
    local RC="0"
    for i in "$3" "$4"; do
      if [ -n "$i" ]; then
        download_img_if_changed "$1" "$i" || RC="1"
      fi
    done
    sendlog
    cd / ; mountcache "$2" -r
    # don't sync local if download failed
    [ "$RC" = "1" ] && return 1
    # Also update LINBO, while we are here.
    update "$1" "$2"
    linbo_update_gui
  fi
  shift
  syncl "$@"
}

# update server cachedev force
# updates grub and linbo stuff
update(){
  # do not execute in localmode
  localmode && return 0

  echo -n "update " ;  printargs "$@"
  local doneflag="/tmp/.update.done"
  local force="$3"

  if [ -e "$doneflag" -a -z "$force" ]; then
    echo "LINBO-Update wurde schon ausgefuehrt!"
    return 0
  else
    rm -f "$doneflag"
  fi

  local rebootflag="/tmp/.linbo.reboot"
  local reboot
  local RC=0
  local group="$(hostgroup)"
  local server="$1"
  local cachelabel="$(print_partlabel "$2")"
  local cachedev="$(print_realdev "$cachelabel")"
  [ -z "$cachedev" ] && cachedev="$2"
  #local disk="${cachedev%%[1-9]*}"
  local grubdir="/cache/boot/grub"
  mountcache "$cachedev" || return 1
  mkdir -p "$grubdir"

  cd /cache
  # detect non pae cpu
  if [ -z "$suffix" ]; then
    grep ^flags /proc/cpuinfo | head -1 | grep -wq pae || suffix="-np"
  fi
  local md5_before
  local md5_after
  local md5_current
  local i
  local myname="$(clientname)"
  local cfgfile
  local sambadomain

  # local restore of start.conf in cache (necessary if cache partition was formatted before)
  [ -s start.conf ] || cp /start.conf .

  # check for linbo/linbofs updates on server
  # download newer linbo/linbofs if applicable and check download
  echo "Looking for LINBO updates."
  # first check md5sum of linbofs
  [ -e linbofs64.lz ] && md5_before="$(md5sum linbofs64.lz | awk '{ print $1 }')"
  [ -e linbofs64.lz.md5 ] && mv linbofs64.lz.md5 linbofs64.lz.md5.bak
  download "$server" linbofs64.lz.md5
  md5_after="$(cat linbofs64.lz.md5 2> /dev/null)"
  if [ -z "$md5_after" ]; then
    echo "Failed to download linbofs64.lz.md5!" >&2
    [ -e linbofs64.lz.md5.bak ] && mv linbofs64.lz.md5.bak linbofs64.lz.md5
    return 1
  fi
  rm -f linbofs64.lz.md5.bak
  # if the linbofs checksum differs, download recent versions of linbofs and linbo
  if [ "$md5_before" != "$md5_after" ]; then
    # first linbofs
    download "$server" linbofs64.lz
    # verify download
    md5_current="$(md5sum linbofs64.lz | awk '{ print $1 }')"
    if [ "$md5_current" != "$md5_after" ]; then
      echo "Checksums differ, failed to download linbofs64.lz!" >&2
      return 1
    fi
    # second linbo
    download "$server" linbo64
    download "$server" linbo64.md5
    # verify download
    md5_after="$(cat linbo64.md5 2> /dev/null)"
    md5_current="$(md5sum linbo64 | awk '{ print $1 }')"
    if [ "$md5_current" != "$md5_after" ]; then
      echo "Checksums differ, failed to download linbo64!" >&2
      return 1
    fi
    # flag a reboot if linbo was not booted over network
    grep -q localboot /proc/cmdline && reboot="yes"
  else
    echo "LINBO is up-to-date."
  fi

  # update wallpaper
  echo "Downloading linbo wallpaper."
  [ -d icons ] || rm -rf icons ; mkdir -p icons
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -L "$server::linbo/icons/linbo_wallpaper.png" icons &> /dev/null
  [ -d /icons ] || rm -rf /icons ; mkdir -p /icons
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" icons/linbo_wallpaper.png /icons &> /dev/null

  # update torrent files
  echo "Downloading torrent and multicast control files."
  for i in "torrent-client.conf" "multicast.list"; do
    rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -L "$server::linbo/$i" "/$i" &> /dev/null
  done

  # update ipxe files
  echo "Updating ipxe file."
  case "$(systemtype)" in
    efi*) download "$server" boot/grub/ipxe.efi ;;
    *) download "$server" boot/grub/ipxe.lkrn ;;
  esac

  # update common grub configs
  echo "Updating common grub configuration."
  cfgfile="$myname.$group.grub.cfg"
  if download "$server" "boot/grub/spool/$cfgfile"; then
    # move downloaded cfgfile in place
    mv "$cfgfile" "$grubdir/grub.cfg"
    echo "grub.cfg was updated."
  fi

  # update host or group specific grub configs
  echo "Updating host and group specific grub configuration."
  for i in "boot/grub/hostcfg/$myname.cfg" "boot/grub/$group.cfg"; do
    if download "$server" "$i"; then
      cfgfile="$(basename "$i")"
      # move downloaded cfgfile in place
      mv "$cfgfile" "$grubdir/custom.cfg"
      echo "custom.cfg was updated."
      break
    fi
  done

  # update grub themes
  echo -n "Updating grub themes ... "
  themesdir="/boot/grub/themes"
  mkdir -p "/cache$themesdir"
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -a --delete "${server}::linbo${themesdir}/" "/cache${themesdir}/" || RC=1
  if [ "$RC" = "1" ]; then
    echo "Failed!" >&2
    return 1
  else
    echo "OK!"
  fi

  # update linuxmuster-win scripts
  echo -n "Updating linuxmuster-win ... "
  [ -d /cache/linuxmuster-win ] || mkdir -p /cache/linuxmuster-win
  rsync --skip-compress="$RSYNC_SKIP_COMPRESS" -a --exclude=*.ex --delete --delete-excluded "$server::linbo/linuxmuster-win/" /cache/linuxmuster-win/ || RC=1
  if [ "$RC" = "1" ]; then
    echo "Failed!" >&2
    return 1
  else
    echo "OK!"
  fi

  # unix2dos and sambadomain fix
  [ -s /cache/hostname ] && sambadomain="$(awk -F\. '{print $2}' /cache/hostname | tr a-z A-Z)"
  for i in /cache/linuxmuster-win/*.reg; do
    unix2dos "$i"
    [ -n "$sambadomain" ] && sed -i "s|SAMBADOMAIN|$sambadomain|g" "$i"
  done

  # finally update/install grub stuff
  if mk_boot; then

    # set efi bootorder to local,network
    [ -d /sys/firmware/efi ] && set_efibootorder

    # remove for old legacy grub stuff
    if [ -e "$grubdir/stage1" -o -e "$grubdir/menu.lst" ]; then
      echo "Remove grub legacy, reboot is necessary."
      rm -f "$grubdir"/*stage* "$grubdir"/menu.lst gpxe.krn
      if [ -e /cache/update.log ]; then
        cat /cache/update.log >> /tmp/linbo.log
        sendlog
      fi
      reboot="yes"
    fi

  else
    RC="1"
  fi

  if [ "$RC" = "0" ]; then
    echo "Linbo & grub update successfully finished."
    touch "$doneflag"
    [ -n "$reboot" ] && touch "$rebootflag"
  else
    echo "Linbo & grub update failed!" >&2
  fi

  sendlog
  return "$RC"
}

# initcache server cachedev downloadtype images...
initcache(){
  # do not execute in localmode
  localmode && return 0
  echo -n "initcache " ;  printargs "$@"
  local server="$1"
  local cachedev="$2"
  local label="$(print_partlabel "$2")"
  local download_type="$3"
  local i
  local u
  local used_images
  local group
  local found
  if remote_cache "$cachedev"; then
    echo "Cache $cachedev is not local, skipping update."
    return 1
  fi
  if [ -n "$FORCE_FORMAT" ]; then
    local cachefs="$(fstype_startconf "$cachedev")"
    if [ -n "$cachefs" ]; then
      echo "Formatting cache partition $cachedev ..."
      format "$cachedev" "$cachefs" "$label" 2>> /tmp/linbo.log || return 1
    fi
  fi
  mountcache "$cachedev" || return 1
  cd /cache
  shift; shift; shift

  # clean up obsolete image files
  used_images="$(grep -i ^baseimage /start.conf | awk -F\= '{ print $2 }' | awk '{ print $1 }')"
  #used_images="$used_images $(grep -i ^image /start.conf | awk -F\= '{ print $2 }' | awk '{ print $1 }')"
  for i in *.qcow2 *.cloop; do
    [ -e "$i" ] || continue
    found=0
    for u in $used_images; do
      if [ "$i" = "$u" ]; then
        found=1
        break
      fi
    done
    if [ "$found" = "0" ]; then
      echo "Removing obsolete image file $i." | tee -a /tmp/image.log
      rm -f "$i" "$i".*
    fi
  done

  # update cache files
  for i in "$@"; do
    if [ -n "$i" ]; then
      download_img_if_changed "$server" "$i" "$download_type"
    fi
  done

  # linbo & gui update
  rm -f /tmp/.update.done
  update "$server" "$cachedev"
  linbo_update_gui
}

### Main ###
# DEBUG linbo_gui:
# echo -n "Running: $cmd "
# count=1
# for i in "$@"; do
#  echo -n "$((count++))=$i,"
# done
# echo ""
# sleep 1

# readfile cachepartition filename [destinationfile]
readfile(){
  local RC=0
  mountcache "$1" || return 1
  if [ -n "$3" ]; then
    cp -a /cache/"$2" "$3"
  else
    cat /cache/"$2"
  fi
  RC="$?"
  #sendlog
  #umount /cache
  return "$RC"
}

# writefile cachepartition filename [sourcefile]
writefile(){
  local RC=0
  mountcache "$1" -w || return 1
  if cache_writable; then
    if [ -n "$3" ]; then
      cp -a "$3" /cache/"$2"
    else
      cat > /cache/"$2"
    fi
    RC="$?"
  else
    echo "Cache ist nicht schreibbar, Datei $2 nicht gespeichert." >&2
    RC=1
  fi
  #sendlog
  mountcache "$1" -r
  return "$RC"
}

# ready - check if LINBO is ready (timeout 120 seconds)
ready(){
  # Files /tmp/linbo-network.done and /tmp/linbo-cache.done created by init.sh
  local count=0
  while [ ! -e /tmp/linbo-network.done -o ! -e /tmp/linbo-cache.done -o ! -s start.conf ]; do
    sleep 1
    #  echo -n "."
    count=`expr $count + 1`
    if [ "$count" -gt 120 ]; then
      echo "Zeitueberschreitung, LINBO noch nicht fertig. :-(" >&2
      return 1
    fi
  done
  localmode || echo "Netzwerk OK."
  echo "Lokale Festplatte(n) OK."
  return 0
}

mac(){
  local iface
  local mac
  iface="$(LANG=C route | grep ^default | awk '{ print $8 }' 2> /dev/null)"
  [ -n "$iface" ] && mac="$(LANG=C ifconfig "$iface" | grep HWaddr | awk '{print $5}' | tr a-z A-Z)"
  [ -z "$mac" ] && mac="OFFLINE"
  echo "$mac"
}

# Find all available batteries, get their capacity and output capacity of first found battery
battery(){
  find /sys/class/power_supply/ -name 'BAT*' -exec cat {}/capacity \; | head -n 1
}

# register server user password room hostname ip group role
register(){
  local RC=1
  local room="$4"
  local client="$5"
  local ip="$6"
  local group="$7"
  local role="$8"
  [ -z "$role" ] && role="classroom-studentcomputer"
  local macaddr="$(mac)"
  [ "$maccaddr" = "OFFLINE" ] && return 1
  local info="$room;$client;$group;$macaddr;$ip;;;;$role;;1"
  # Plausibility check
  if echo "$client" | grep -qi '[^a-z0-9-]'; then
    echo "Falscher Rechnername: '$client'," >&2
    echo "Rechnernamen duerfen nur Buchstaben [a-z0-9-] enthalten." >&2
    return 1
  fi
  if echo "$group" | grep -qi '[^a-z0-9_-]'; then
    echo "Falscher Gruppenname: '$group'," >&2
    echo "Rechnergruppen duerfen nur Buchstaben [a-z0-9_-] enthalten." >&2
    return 1
  fi
  cd /tmp
  echo "$info" '>' "$client.new"
  echo "$info" >"$client.new"
  echo "Uploade $client.new auf $1..."
  export RSYNC_PASSWORD="$3"
  interruptible rsync --skip-compress="$RSYNC_SKIP_COMPRESS" --progress -HaP "$client.new" "$2@$1::linbo-upload/$client.new" ; RC="$?"
  cd /
  return "$RC"
}

ip(){
  local iface
  local ip
  iface="$(LANG=C route | grep ^default | awk '{ print $8 }' 2> /dev/null)"
  [ -n "$iface" ] && ip="$(LANG=C ifconfig "$iface" | grep 'inet addr:' | awk -F\: '{ print $2 }' | awk '{ print $1 }')"
  [ -z "$ip" ] && ip="OFFLINE"
  echo "$ip"
}

netmask(){
  [ -e /tmp/dhcp.log ] || return 0
  grep ^subnet /tmp/dhcp.log | awk -F\' '{print $2}' | head -1
}

bitmask(){
  local netmask="$(netmask)"
  [ -z "$netmask" ] && return 0
  ipcalc -p "$netmask" | awk -F\= '{print $2}'
}

clientname(){
  if [ -s /tmp/network.ok ]; then
    source /tmp/network.ok
    echo "$hostname"
    return
  fi
  local device="$(cachedev)"
  if [ -b "$device" ]; then
    if mountcache $device -r &> /dev/null; then
      if [ -s /cache/hostname ]; then
        awk -F\. '{ print $1 }' /cache/hostname
        return
      fi
    fi
  fi
  hostname
}

cpu(){
  cat /proc/cpuinfo | grep name | sed 's,model.*:\ ,,'
}

memory(){
  free | grep Mem | awk '{printf "%d MB\n",$2 / 1024}'
}

size(){
  if mountpart "$1" /mnt -r 2>> /tmp/linbo.log; then
    df -k /mnt 2>/dev/null | tail -1 | \
      awk '{printf "%.1f/%.1fGB\n", $4 / 1048576, $2 / 1048576}' 2>/dev/null
    umount /mnt
  else
    local d=$(get_partition_size "$1")
    if [ "$?" = "0" -a "$d" -ge 0 ] 2>/dev/null; then
      echo "$d" | awk '{printf "%.1fGB\n",$1 / 1048576}' 2>/dev/null
    else
      echo " -- "
    fi
  fi
  return 0
}

# list cloop images in cache, listimages cachedev
listimages(){
  mountcache "$1" -r || return 1
  ls -1 /cache/*.[cq][lc][o][ow][p2] || return 1
}

#
# jweiher, angepasst tschmitt
# Ermittelt den logisch naechsten Hostnamen, um die Rechneraufnahme zu
# erleichtern
#
preregister() {
  local LAST_REGISTERED="/tmp/last_registered"
  interruptible rsync --skip-compress="$RSYNC_SKIP_COMPRESS" --progress -HaP "$1::linbo/last_registered" "$LAST_REGISTERED" ; RC="$?"
  local LASTWORKSTATION="$(grep ^[a-z0-9] "$LAST_REGISTERED" | tail -n 1)"

  if [ "$LASTWORKSTATION" == "" ]; then
    echo ",,," > /tmp/newregister
    rm -f "$LAST_REGISTERED"
    return 0
  fi

  local LASTGROUP="$(echo $LASTWORKSTATION | cut -d ";" -f 3)"
  local LASTROOM="$(echo $LASTWORKSTATION | cut -d ";" -f 1)"
  local LASTHOST="$(echo $LASTWORKSTATION | cut -d ";" -f 2)"
  local LASTIP="$(echo $LASTWORKSTATION | cut -d ";" -f 5)"

  # Naechste IP ermitteln
  local NEXTIP="$(echo -n $LASTIP | cut -d "." -f 1-3).$(($(echo $LASTIP | cut -d "." -f 4)+1))"

  # Naechsten Hostnamen ermitteln
  local HOSTNAMECOUNTER="$(echo $LASTHOST | grep -Eo "[0-9]+$")"
  local NEXTCOUNT
  if [ ! "$HOSTNAMECOUNTER" == "" ]; then
    NEXTCOUNT=$(expr $HOSTNAMECOUNTER + 1)
    # Left fill with zeroes
    while [ "${#NEXTCOUNT}" -lt "${#HOSTNAMECOUNTER}" ]; do
      NEXTCOUNT=0$NEXTCOUNT
    done

    # Build new hostname
    local NEXTHOST="$(echo -n $LASTHOST | sed "s/${HOSTNAMECOUNTER}$//g")$NEXTCOUNT"
  else
    NEXTHOST="$LASTHOST"
  fi
  rm -f "$LAST_REGISTERED"
  echo "$LASTROOM,$LASTGROUP,$NEXTHOST,$NEXTIP" > /tmp/newregister
  return 0
}

version(){
  local versionfile="/etc/linbo-version"
  if [ -s "$versionfile" ]; then
    cat "$versionfile"
  else
    echo "LINBO 2.x"
  fi
}

# Main

case "$cmd" in
  ip) ip ;;
  netmask) netmask ;;
  bitmask) bitmask ;;
  hostname) clientname ;;
  cpu) cpu ;;
  memory) memory ;;
  mac) mac ;;
  battery) battery ;;
  size) size "$@" ;;
  listimages) listimages "$@" ;;
  authenticate) authenticate "$@" ;;
  create) create "$@" ;;
  start) start "$@" ;;
  label) label_allpartitions ;;
  partition_noformat) export NOFORMAT=1; partition ;;
  partition) partition ;;
  preregister) preregister "$@" ;;
  download) download "$@" ;;
  initcache) initcache "$@" ;;
  initcache_format) echo "initcache_format gestartet."; export FORCE_FORMAT=1; initcache "$@" ;;
  mountcache) mountcache "$@" ;;
  mount) mountpart "$@" ;;
  fstype) fstype "$@" ;;
  readfile) readfile "$@" ;;
  ready) ready "$@" ;;
  register) register "$@" ;;
  sync) syncl "$@" && { cache="$1"; shift 3; start "$1" "$2" "$3" "$4" "$5" "$cache"; } ;;
  syncstart) syncr "$@" && { cache="$2"; shift 4; start "$1" "$2" "$3" "$4" "$5" "$cache"; } ;;
  syncr) syncr "$@" && { cache="$2"; shift 4; start "$1" "$2" "$3" "$4" "$5" "$cache"; } ;;
  synconly) syncr "$@" ;;
  update) update "$@" ;;
  upload) upload "$@" ;;
  version) version ;;
  writefile) writefile "$@" ;;
  *) help "$cmd" "$@" ;;
esac

# Return returncode
exit "$?"
